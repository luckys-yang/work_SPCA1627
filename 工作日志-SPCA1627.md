---
title: 工作日志-SPCA1627
cover: /img/num176.webp
categories:
  - 工作
comments: false
password: 20240304
message: 公司机密，暂不开放...
abbrlink: 3afaf825
date: 2024-03-04 17:38:54
---

## 前言

{% note blue 'fas fa-fan' flat %}参考文章{% endnote %}

[HC32L196 驱动 ST7789v 经验](https://blog.csdn.net/junzheng/article/details/127752145?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168416105416800186524622%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168416105416800186524622&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-127752145-null-null.142%5Ev87%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&utm_term=HC32L196%20%E9%A9%B1%E5%8A%A8%20ST7789V%20%E7%BB%8F%E9%AA%8C&spm=1018.2226.3001.4187)

[TFT驱动ST7789使用总结](https://blog.csdn.net/qq_28576837/article/details/130694215)



{% note blue 'fas fa-fan' flat %}我的工程{% endnote %}

`240226_新板_按键_屏显_偏红_L_开关机_曝光`



## 修改记录

> xxx(yyy)：xxx是原理图上的，yyy是程序；里对应的

> 在拍照和录像页面下
>
> - UP1(UP1)键
>
> - [x] 按下打开和关闭补光灯
>
> ```cpp
> case SP1K_MSG_KEY_PRESS_UP: // 【上按键按下消息】
> {
>     // 应用程序调整宏获取成功 && 进入应用程序调整宏标志位 为真
>     if (app_adjust_macro_sta_get() && (Flag_true == enterMacroadjust))
>     {
>         cur_idx = !cur_idx;               // 当前选择索引取反
>         app_quick_delete_dialog(cur_idx); // 快速删除对话框
>         break;
>     }
> 
>     if (Status_0 == puiPara->FlashLed) // 闪光灯 -> 关闭
>     {
>         puiPara->FlashLed = Status_1; // 闪光灯 -> 自动
>     }
>     else if (Status_1 == puiPara->FlashLed) // 闪光灯 -> 自动
>     {
>         puiPara->FlashLed = Status_0; // 闪光灯 -> 关闭
>     }
>     appSnapFlashLed(1);                // 快门时闪光灯控制 --- 常开
>     uiUpdateFlashLed(LCD_WIDTH, 0, 0); // 根据当前闪光灯模式更新相应的图标显示状态
>     break;
> }
> ```
>

> 拍照页面下：
>
> - BACK1(BACK1)键
>
> - [x] 按下定时拍照键，切换 `关闭->2s->5s->10s->关闭...`
>
> ```cpp
> case SP1K_MSG_KEY_PRESS_BACK: // 【返回按键按下消息】
> {
>     // 应用程序调整宏获取成功 && 进入应用程序调整宏标志位 为真
>     if (app_adjust_macro_sta_get() && (Flag_true == enterMacroadjust))
>     {
>         cur_idx = !cur_idx;               // 当前选择索引取反
>         app_quick_delete_dialog(cur_idx); // 快速删除对话框
>         break;
>     }
> 
>     // 场景 != 自动
>     if (puiPara->SceneMode != PRV_SCENE_AUTO)
>     {
>         puiPara->SceneMode = PRV_SCENE_AUTO; // 场景 -> 自动
>         uiSceneModeUpdate();            // 更新场景模式图标
>     }
> 
>     // 拍摄模式状态 != 连拍
>     if (puiPara->DriverMode != PRV_SNAP_BURST)
>     {
>         puiPara->DriverMode++; // 拍摄模式状态++
> 
>         if (PRV_SNAP_BURST == puiPara->DriverMode)  // 拍摄模式状态 == 连拍
>         {
>             puiPara->DriverMode = PRV_SNAP_SINGLE; // 拍摄模式状态 -> 关闭
>         }
>     }
>     // appDriveModeSet();  // 根据不同的拍摄模式设置相应的拍摄参数
>     uiUpdateSnapMode(LCD_WIDTH, 0, 0); // 刷新PV模式下的拍摄模式图标
>     break;
> }
> ```
>
> 
>
> - RIGHT1(PB)键
>
> - [x] 按下连拍键，切换 `无->连拍->无...`
>
> ```cpp
> case SP1K_MSG_KEY_PRESS_PB: // 【PB按键按下消息】
> {
>     // 场景 != 自动
>     if (puiPara->SceneMode != PRV_SCENE_AUTO)
>     {
>         puiPara->SceneMode = PRV_SCENE_AUTO; // 场景 -> 自动
>         uiSceneModeUpdate();            // 更新场景模式图标
>     }
>     else // 场景 == 自动
>     {
>         if (PRV_SNAP_BURST == puiPara->DriverMode) // 拍摄模式状态 -> 连拍
>         {
>             puiPara->DriverMode = PRV_SNAP_SINGLE; // 拍摄模式状态 -> 关闭
>         }
>         else
>         {
>             puiPara->DriverMode = PRV_SNAP_BURST; // 拍摄模式状态 -> 连拍
>         }
>         // appDriveModeSet();  // 根据不同的拍摄模式设置相应的拍摄参数
>         uiUpdateSnapMode(LCD_WIDTH, 0, 0); // 刷新PV模式下的拍摄模式图标
>     }
>     // 拍摄模式状态 != 关闭
>     if (puiPara->DriverMode != PRV_SNAP_SINGLE)
>     {
>         AF_Set(0);                 // AF关闭
>         appAFCtrl(AF_CTRL_DISABL); // AF自动对焦电源控制 --- 关闭
>     }
>     break;
> }
> ```
>
> 
>
> - MODE1(MODE1)按键
>
> - [x] 按下进入录像界面
>
> ```cpp
> case SP1K_MSG_KEY_PRESS_MODE: // 【模式按键按下消息】
> {
>     if (Flag_true == enterMacroadjust) // 进入应用程序调整宏标志位 为真
>     {
>         enterMacroadjust = Flag_false;
>     }
> 
>     sp1kDispImgWinEn(0);                                 // 启用预览层 --- 禁用
>     sp1kHalWait(200);                                    // 延时
>     sp1kPreviewCropSizeSet(1280, 960);                   // 设置预览裁剪尺寸
>     sp1kPreviewSet(0, 1280, 720, sp1kPvZoomFctGet(), 1); // 设置预览参数
>     sp1kHalWait(100);                                    // 延时
> 
>     osMsgPost(SP1K_MSG_STATE_TO_VIDEO_VIEW); // 发送 录像视图状态消息
>     flag_menu_back_videoview = 0;
>     break;
> }
> ```
>
> 
>
> - (T1)ZOOM_IN放大键
>
> - [x] 按下
>
> ```cpp
> case SP1K_MSG_KEY_PRESS_ZOOM_IN: // 【放大按键按下消息】
> {
>     vStillViewParamater.stillZoomRptCnt = 0;
>     appOsdModeSw(0); // 控制 OSD 模式 --- 重置为带 OSD 的 LCD 模式
>     pvZoomSts |= 0xf0;
> 
>     if (!sp1kSnapParamGet(SP1K_SNAP_PARAM_PHOTO_FRM_OPT)) // 获取快照参数
>     {
>         sp1kAeSetModeEn(AE_DISABLE); // 启用/禁用 AE 控制 --- 禁用
>         sp1kAwbDisable();            // 禁用 awb
>     }
> 
>     sp1kFdDisable(); // 启用或禁用脸部检测 --- 禁用
>     break;
> }
> ```
>
> - [x] 松开，长按
>
> ```cpp
> case SP1K_MSG_KEY_REPEATE_ZOOM_IN: // 【放大按键长按消息】
> case SP1K_MSG_KEY_RELEASE_ZOOM_IN: // 【放大按键释放消息】
> {
>     vStillViewParamater.stillZoomRptCnt = 0;
>     pvZoomSts &= ~0xf0;
> 
>     // 快速捕获 -> 打开 ||
>     if ((SPEEDY_CAPTURE_ON == puiPara->SpeedyCap) || (SPEEDY_CAPTURE_REC_ON == puiPara->SpeedyCapRec))
>     {
>         UINT8 ZfStatus;
> 
>         appVideoViewTele();                          // 视频键启动过程
>         if (sp1kVideoRecStatusGet() == VID_REC_IDLE) // 录像状态获取 -> 空闲
>         {
>             ZfStatus = sp1kVideoRecZoomFacSet(video_zoomFactor, 0); // 设置当前有效缩放
>         }
>         else // 录像状态获取 -> 录像中/暂停
>         {
>             ZfStatus = sp1kVideoRecZoomFacSet(video_zoomFactor, 1);
>         }
> 
>         if (ZfStatus == FAIL) // 错误
>         {
>             appVideoViewTeleReply();
>         }
> 
>         uiUpdateOSDPvZoom(video_zoomFactor, 1); // 在 PV 模式下刷新缩放系数
>         sp1kAeSetModeEn(AE_ENABLE);             // 启用/禁用 AE 控制 --- 启用
>         sp1kAwbEnable();                        // 启用 awb
>     }
>     else
>     {
>         if (!sp1kSnapParamGet(SP1K_SNAP_PARAM_PHOTO_FRM_OPT))
>         {
>             appStillViewZoomIn();
>             stillZFctor = PvZoomCtrl.factor;
>             stillCurrLog = PvZoomCtrl.curLog;
>         }
>         sp1kAeSetModeEn(AE_ENABLE); // 启用/禁用 AE 控制 --- 启用
>         sp1kAwbEnable();            // 启用 awb
>     }
> 
>     if (puiPara->FDMode == FDMODE_ON) // 脸部检测->打开
>     {
>         sp1kFdEnable(); // 启用或禁用脸部检测 --- 启用
>     }
>     break;
> }
> ```
>
> 
>
> - (W1)ZOOM_OUT缩小键
>
> - [x] 按下
>
> ```cpp
> case SP1K_MSG_KEY_PRESS_ZOOM_OUT: // 【缩小按键按下消息】
> {
>     vStillViewParamater.stillZoomRptCnt = 0;
> 
>     appOsdModeSw(0); // 控制 OSD 模式 --- 重置为带 OSD 的 LCD 模式
>     pvZoomSts |= 0x0f;
> 
>     if (!sp1kSnapParamGet(SP1K_SNAP_PARAM_PHOTO_FRM_OPT))
>     {
>         sp1kAeSetModeEn(AE_ENABLE); // 启用/禁用 AE 控制 --- 启用
>         sp1kAwbDisable();           // 禁用 awb
>     }
> 
>     sp1kFdDisable(); // 启用或禁用脸部检测 --- 禁用
>     break;
> }
> ```
>
> - [x] 松开，长按
>
> ```cpp
> case SP1K_MSG_KEY_REPEATE_ZOOM_OUT: // 【缩小按键长按消息】
> case SP1K_MSG_KEY_RELEASE_ZOOM_OUT: // 【缩小按键释放消息】
> {
>     vStillViewParamater.stillZoomRptCnt = 0;
>     pvZoomSts &= ~0x0f;
> 
>     // 快速捕获 -> 打开 ||
>     if ((SPEEDY_CAPTURE_ON == puiPara->SpeedyCap) || (SPEEDY_CAPTURE_REC_ON == puiPara->SpeedyCapRec))
>     {
>         appVideoViewWide(); // 关于下降过程的简短视频
> 
>         if (sp1kVideoRecStatusGet() == VID_REC_IDLE) // 录像状态获取 -> 空闲
>         {
>             sp1kVideoRecZoomFacSet(video_zoomFactor, 0);
>         }
>         else
>         {
>             sp1kVideoRecZoomFacSet(video_zoomFactor, 1);
>         }
>         uiUpdateOSDPvZoom(video_zoomFactor, 1); // 在 PV 模式下刷新缩放系数
>         sp1kAeSetModeEn(AE_ENABLE);             // 启用/禁用 AE 控制 --- 启用
>         sp1kAwbEnable();                        // 启用 awb
>     }
>     else
>     {
>         appStillViewZoomOut();
>         stillZFctor = PvZoomCtrl.factor;
>         stillCurrLog = PvZoomCtrl.curLog;
>         sp1kAeSetModeEn(AE_ENABLE); // 启用/禁用 AE 控制 --- 启用
>         sp1kAwbEnable();            // 启用 awb
>     }
> 
>     if (puiPara->FDMode == FDMODE_ON) // 脸部检测->打开
>     {
>         sp1kFdEnable(); // 启用或禁用脸部检测 --- 启用
>     }
>     break;
> }
> ```
>
> - AF键 聚焦
>
> - [x] 按下
>
> ```cpp
> case SP1K_MSG_KEY_PRESS_AF: // 【自动对焦按键按下消息】
> {
>     if (!af_timer_out && !af_timer_start)
>     {
>         af_timer_start = Flag_true; // 开始标志位
>         break;
>     }
>     else if (af_timer_out)
>     {
>         af_timer_out = Flag_false;
>         af_timer_start = Flag_false;
>     }
> 
>     appStillOsdInit(1); // 初始化拍照模式下界面
> 
>     // 【支持AF调焦】【支持拍照前自动对焦】
> #if (SUPPORT_AF && SUPPORT_SNAP_AF)
>     // 【支持AF调焦】【支持两段式固定焦距】
> #if (SUPPORT_AF && SUPPORT_FIXED_AF)
>     puiPara->SnapAf = Status_1;            // 自动对焦 --- 打开
>     // puiPara->DriverMode = PRV_SNAP_SINGLE; // 拍摄模式 --- 关闭
> #endif
> 
>     appAFCtrl(AF_CTRL_ENABLE); // AF自动对焦电源控制 --- 打开
>     afbackfaruiclearflag = 0;
>     osMsgPost(SP1K_MSG_SYS_AF_START); // 发送 AF开始消息
> #endif
>     break;
> }
> ```
>
> ```cpp
> // 【---------------支持AF调焦------------------】
> #if SUPPORT_AF
> case SP1K_MSG_SYS_AF_START: // 【AF开始消息】
> {
>     affarflag = 0;
>     AF_AfCalStatusShow(AF_BOX_COLOR_YELLOW, AF_BOX_DISPLAY); // 对焦显示框
> 
>     AF_Set(0);       // AF关闭
>     sp1kHalWait(50); // 延时
>     AF_startCalAF(); // 启动AF自动对焦校准
>     break;
> }
> case SP1K_MSG_SYS_AF_CAL: // 【AF校准消息】
> {
>     AF_CalAF();
>     break;
> }
> case SP1K_MSG_SYS_AF_BACK_FAR: // 【AF退出消息】
> {
>     if (afbackfaruiclearflag == 0)
>     {
>         sp1kOsdClearCharExt(128, 88, 64, 64); // 清除屏幕特定区域内容
>     }
>     puiPara->SnapAf = Status_0; // 自动对焦 --- 关闭
> 
>     AF_Set(0);                 // AF关闭
>     appAFCtrl(AF_CTRL_DISABL); // AF自动对焦电源控制 --- 失能
>     break;
> }
> case SP1K_MSG_SYS_AF_SUCCESS: // 【AF成功消息】
> {
>     AF_AfCalStatusShow(AF_BOX_COLOR_GREEEN, AF_BOX_DISPLAY); // 绿, 显示
>     sp1kHalWait(150);                                        // 延时
>     AF_AfCalStatusShow(AF_BOX_COLOR_GREEEN, AF_BOX_HIDE);    // 绿, 不显示
>     sp1kHalWait(150);                                        // 延时
>     AF_AfCalStatusShow(AF_BOX_COLOR_GREEEN, AF_BOX_DISPLAY); // 绿, 显示
>     sp1kHalWait(150);                                        // 延时
> 
>     if (app_adjust_macro_sta_get()) // 返回 adjust_macro_sta
>     {
>         puiPara->SnapAf = Status_0;  // 自动对焦 --- 关闭
>         app_adjust_macro_sta_set(0); // 赋值adjust_macro_sta
>         appAFCtrl(AF_CTRL_DISABL);   // AF自动对焦电源控制 --- 失能
>     }
>     else
>     {
>         affarflag = 1;
>     }
> 
>     ENTER_CRITICAL(vStillViewParamater.sts); // 进入临界区
>     sp1kADCSarSel(0x02);                     // 选择 SAR ADC 通道
>     sp1kHalWait(50);                         // 延时
>     adcVal = sp1kADCValueSnapIntr();         // 捕捉刚刚在中断中使用的 ADC 值
>     EXIT_CRITICAL(vStillViewParamater.sts);  // 退出临界区
> 
>     if (adcVal <= (0 + 10))
>     {
>         osMsgPost(SP1K_MSG_KEY_PRESS_S2); // 发送 S2按键按下消息
>     }
>     break;
> }
> case SP1K_MSG_SYS_AF_FAIL: // 【AF失败消息】
> {
>     AF_AfCalStatusShow(0, 1); // 根据给定的状态和标志来显示或清除一个特定的OSD选择窗口
>     sp1kHalWait(150);         // 延时
>     AF_AfCalStatusShow(0, 0); // 根据给定的状态和标志来显示或清除一个特定的OSD选择窗口
>     sp1kHalWait(150);         // 延时
>     AF_AfCalStatusShow(0, 1); // 根据给定的状态和标志来显示或清除一个特定的OSD选择窗口
>     sp1kHalWait(150);         // 延时
> 
>     if (app_adjust_macro_sta_get()) // 返回 adjust_macro_sta
>     {
>         puiPara->SnapAf = Status_0;
>         app_adjust_macro_sta_set(0); // 赋值adjust_macro_sta
>         appAFCtrl(AF_CTRL_DISABL);   // AF自动对焦电源控制 --- 失能
>     }
> 
>     break;
> }
> #endif
> ```
>
> - 拍照键
>
> - [x] 按下 拍照
>
> ```cpp
> case SP1K_MSG_KEY_PRESS_SNAP: // 【快照按键按下消息】无break
> {
>     af_timer_start = 0;
> }
> ```
>
> ```cpp
> case SP1K_MSG_KEY_PRESS_S2: // 【S2按键按下消息】
> case SP1K_MSG_FD_SMILE:     // 【微笑检测消息】
> case SP1K_MSG_MD_ACTION:    // 【运动检测消息】
> {
>     if (sp1kSD_CdGet()) // 获取 SD 卡检测值 --- 无SD卡直接返回
>     {
>         break;
>     }
>     sp1kBtnDisableAll(); // 禁用所有按键
> 
>     if (PRV_SNAP_SINGLE == puiPara->DriverMode) // 拍摄模式是关闭则
>     {
>         app_set_led(LED_BUSY_OFF); // 忙指示灯控制 --- 灭
> 
>         appSnapFlashAdjustsAe(puiPara->FlashLed); // 根据闪光灯状态进行调整曝光 色彩校正
>         appSnapFlashLed(Status_1);                // 闪光灯控制 --- 常开
>         sp1kHalWait(500);                         // 延时
> 
>         if (puiPara->FlashLed != Status_1) // 闪光灯状态不等于 自动
>         {
>             appSnapFlashLed(Status_0); // 闪光灯控制 --- 关闭
>             sp1kHalWait(500);          // 延时
>         }
>     }
> 
>     /***************Just for QA test @start***************************************/
>     if (0x55 == AutoTestMode)
>     {
>         /*
>         模拟在自动测试模式下相机的操作流程
>         */
>         // 声明并初始化局部变量osdMaxX和osdMaxY
>         UINT8 osdMaxX, osdMaxY;
>         // 静态变量ISize递增
>         static UINT8 ISize = 0;
>         ISize++;
> 
>         // 如果ISize达到最大图像尺寸
>         if (PRV_SIZE_MAX == ISize)
>         {
>             // 重置ISize
>             ISize = 0;
>         }
>         // 更新ui结构体中的ImageSize字段
>         puiPara->ImageSize = ISize;
>         // 获取OSD布局属性
>         sp1kOsdLayoutAttrGet(&osdMaxX, &osdMaxY);
>         // 更新图像大小
>         uiUpdateImgSize(osdMaxX - 9 + vStillViewParamater.Xoffset, 0, 0);
>         // 初始化剩余像素显示
>         uiRemainPixInit(); // mantis #26379
>         // 更新剩余像素显示
>         uiUpdateRemainPix(); // mantis #26379
>         // 等待1000毫秒
>         sp1kHalWait(1000);
>         // 禁用距离测量功能
>         sp1kDistDisable();
>     }
>     /***************Just for QA test @end***************************************/
> 
>     /* 检查环境 是否符合拍摄条件 */
>     if (appSnapEnvChk() != SUCCESS)
>     {
>         sp1kBtnEnableAll(); // 启用所有按键
>         break;
>     }
> 
>     /* 发送信息等待 AE/AWB 就绪 */
>     pvWaitCnt = 0;
>     osMsgPost(SP1K_MSG_3A_WAIT_PROC); // 发送 等待3A处理消息
>     sp1kFdDisable();                  // 使能人脸检测功能
> 
>     /* 等待 AE/AWB 就绪时禁用所有按钮 */
>     // 视频捕获获取 --- 视频捕获模式 != 剪辑捕获
>     if (sp1kVideoCapParamGet(SP1K_VD_CAP_MOD) != SP1K_SPEEDCAP_CLIP)
>     {
>         sp1kBtnDisableAll(); // 禁用所有按键
>     }
> 
>     if (puiPara->SpeedyCap == SPEEDY_CAPTURE_ON) // 快速捕获状态 -> 打开
>     {
>         puiPara->StampVideoMode = puiPara->StampMode; // 视频下日戳状态 = 日戳状态
>         appVideoStampSet(); // 设置视频时间戳(在 osdinit 之后移动)
>     }
> 
>     if (puiPara->SpeedyCapRec == SPEEDY_CAPTURE_REC_ON) // 速拍录制状态 -> 打开
>     {
>         puiPara->StampVideoMode = puiPara->StampMode; // 视频下日戳状态 = 日戳状态
>         appVideoStampSet();                           // 设置视频时间戳(在 osdinit 之后移动)
>     }
>     break;
> }
> ```
>
> - OK键 进入菜单	
>
> - [x] 按下
>
> ```cpp
> case SP1K_MSG_KEY_PRESS_OK: // 【确认按键按下消息】
> {
>     afbackfaruiclearflag = 0;
>     versionclearflag = 0;
> 
>     uiOsdVerDisp(FW_VERSION, 0);    // 显示垂直OSD信息 版本信息
> 
>     if (Flag_true == enterMacroadjust)    // 进入应用程序调整宏标志位 为真
>     {
>         enterMacroadjust = Flag_false;
>     }
> 
>     // 获取快速拍照状态 -> 快速拍照中
>     if (sp1kSpeedyCapStsGet() == SPEEDCAP_STS_RUNNING)
>     {
>         break;
>     }
>     sp1kFdDisable();   // 启用或禁用脸部检测 --- 禁用
>     sp1kFdSetSmile(0);  // Fd 设置微笑功能 --- 禁用
> 
>     // 快速捕获 -> 打开 ||
>     if (puiPara->SpeedyCap == SPEEDY_CAPTURE_ON || puiPara->SpeedyCapRec == SPEEDY_CAPTURE_REC_ON)
>     {
>         stillZFctor = video_zoomFactor;
>         stillCurrLog = ZoomCurLog;
>     }
>     else
>     {
>         stillZFctor = PvZoomCtrl.factor;
>         stillCurrLog = PvZoomCtrl.curLog;
>     }
> 
>     puiPara->FlashLed = Status_0;  // 闪光灯状态 -> 关闭
>     appSnapFlashLed(0); // 快门时闪光灯控制 --- 关闭
>     uiUpdateFlashLed(LCD_WIDTH, 0, 0);  // 根据当前闪光灯模式更新相应的图标显示状态
> 
>     osMsgPost(SP1K_MSG_STATE_TO_MENU);  // 发送 菜单状态消息
>     break;
> }
> ```

> 菜单页面下：
>
> 







## 板子资源



芯片的IO分为：

 `GPIO`：通用输入/输出引脚

`DGPIO`：数字输入/输出引脚

`SARIN0`：模拟输入引脚

`SARIN2`：模拟输入引脚

## 环境

直接按照keil3即可，安装驱动，安装全部字体在电脑(不然相机字体有问题)



## 工程



{% note red 'fas fa-fan' flat %}

工程用到的原理图，数据手册都在对应工程文件夹里

PS版本是 `22.5.1`

{% endnote %}



### 编译前

它需要执行3个脚本

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-06_09-53-23.webp)

- dev_install.bat

根据输入的参数依次安装传感器、显示器、封装和 HDMI 的驱动程序，这里传入是：

```bash
.\script\dev_install.bat OV_OV5653_RAW_INV AUO_A025BN01_UPS052 NULL EP_EP932 _HW_EVB_ NULL CUSTOM
```

```bash
# 传入的格式
dev_install.bat [sensor type] [panel type] [package type] [hdmi type] [hw platform] [FDP] [customer prj]

# 中文意思
[sensor type]：	传感器类型，可能指定安装的传感器的种类或型号。【OV_OV5653_RAW_INV】
[panel type]：	面板类型，可能指定安装的显示屏类型或规格。【AUO_A025BN01_UPS052】
[package type]：	封装类型，可能指定安装的软件包的类型或格式。【NULL】
[hdmi type]：	HDMI类型，可能指定与安装设备相关的HDMI接口类型或规格。【EP_EP932】
[hw platform]：	硬件平台，可能指定安装设备所使用的硬件平台或架构。【_HW_EVB_】
[FDP]：			FDP，可能是与安装相关的特定功能、组件或选项的缩写。【NULL】
[customer prj]：	客户项目，可能指定安装设备所属的客户项目或标识符。【CUSTOM】
```

```bash
@ECHO OFF	# 关闭命令回显

title Device driver install	# 用于设置命令行窗口的标题为 "Device driver install"

# 设置了工作路径 WORK_PATH 以及四个设备驱动安装脚本的名称
set WORK_PATH=.\script
set FRONT_DRIVER=front_install.bat
set DISP_DRIVER=disp_install.bat
set PACKAGE_DRIVER=package_install.bat
set HDMI_DRIVER=hdmi_install.bat

# 使用 call 命令依次调用了四个设备驱动安装脚本，并传入了相应的参数
call %WORK_PATH%\%FRONT_DRIVER% %1 %5 %6 %7
call %WORK_PATH%\%DISP_DRIVER% %2
call %WORK_PATH%\%PACKAGE_DRIVER% %3
call %WORK_PATH%\%HDMI_DRIVER% %4

:end	# 表示脚本执行结束
```

- res_install.bat

用于执行一系列操作，其中包括根据输入参数重新生成资源文件、生成版本文件，并在完成后显示安装进度完成的消息

```bash
@echo off	# 关闭命令回显

set DOWNLOAD=.\download	# 设置DOWNLOAD变量为.\download，可能是用于存储下载的文件

set PATH_CHK=%DOWNLOAD%\resource\	# 设置PATH_CHK变量为%DOWNLOAD%\resource\，可能是存放资源文件的路径
set FILE_CHK=res.fdk	# 设置FILE_CHK变量为res.fdk，可能是要检查的文件名

set FILE_BAT_VER=.\script\ver_gen.bat	# 设置FILE_BAT_VER变量为.\script\ver_gen.bat，可能是用于生成版本文件的批处理脚本
set FILE_INPUT=.\kernel\ver_svn.h	# 设置FILE_INPUT变量为.\kernel\ver_svn.h，可能是输入的版本文件
set FILE_OUTPUT=.\kernel\ver_svn.h	# 设置FILE_OUTPUT变量为.\kernel\ver_svn.h，可能是输出的版本文件
set DIR_TAG=.\	# 设置DIR_TAG变量为.\，可能是用于标记的目录

# 如果第一个参数不为空，执行下面的操作
if "%1" neq "" (
	set FILE_CHK=res.%1	# 将FILE_CHK设置为res.%1，可能是根据输入参数设定特定的文件名
)

# 如果%PATH_CHK%\%FILE_CHK%文件存在，执行下面的操作
if exist %PATH_CHK%\%FILE_CHK% (

	echo Resource files rebuilding...
	pushd .\script\	# 进入.\script\目录
	call .\menu.bat %1 >NUL	# 调用menu.bat脚本，传递第一个参数，并将输出重定向到NUL，可能是执行菜单脚本并传递参数
	popd	# 返回之前的目录

	echo %FILE_OUTPUT% generating...
	call %FILE_BAT_VER% %DIR_TAG% %FILE_INPUT% %FILE_OUTPUT%	# 调用ver_gen.bat脚本，并传递参数，可能是执行生成版本文件的操作

	del /f /q %PATH_CHK%\%FILE_CHK% >NUL	# 删除%PATH_CHK%\%FILE_CHK%文件
)

echo Install progress completed.	# 显示安装进度已完成的消息
:end	# 表示脚本结束
```

- post.bat

将 Hex 文件转换为 Binary 文件，并将其合并到目标文件中，然后执行下载操作

```bash
@ECHO OFF	# 关闭命令回显

title Post building process	# 设置命令行窗口的标题为“Post building process”

set path=%path%;.\bin	# 将当前目录下的 bin 文件夹添加到系统 PATH 环境变量中，以便能够直接调用其中的可执行文件

# 设置一系列变量，包括工作目录、目标目录、Keil 路径、UsbBoot 路径、工具路径、下载路径、资源目录、源文件名、中间文件名、目标文件名和地图文件路径
set WORK=.\
set OBJ=.\obj
set KEIL=C:\Keil\C51\BIN
set USBBOOT=C:\Progra~1\Sunplus\UsbBoot
set TOOL=.\bin
set DOWNLOAD=.\download
set RESOURCE=resource
set SOURCE=1628
set MIDDLE=FW.BIN
set TARGET=1628.bin
set MAP=.\lst\%SOURCE%.map

# 设置固件大小记录值和固件大小对齐值
set FW_SIZE_RECORD=0x7FF0
set /a FW_SIZE_ALIGN=0

# 如果存在第一个参数，则将下载路径设置为该参数
if "%1" neq "" (
	set DOWNLOAD=%1
)
# 在地图文件中查找是否存在代码或数据重叠，如果找到则跳转到 ERR_OVERLAP 标签
findstr /n /c:"*** OVERLAP ***" %MAP%
if %errorlevel% equ 0 (
	goto ERR_OVERLAP
)
# 检查 Keil IDE 工具是否存在，如果不存在则跳转到 ERR_IDE_NOT_FOUND 标签
if not exist %KEIL%\ohx51.exe (
	goto ERR_IDE_NOT_FOUND
)
# 根据固件大小对齐值选择合适的工具将 Hex 文件转换为二进制文件，并记录固件大小
if %FW_SIZE_ALIGN% equ 0 (
	%TOOL%\HEX2BIN.EXE %OBJ%\%SOURCE%.hex
) else (
	%TOOL%\HEX2BIN_align.EXE %OBJ%\%SOURCE%.hex
)
%TOOL%\sizeRec.exe %OBJ%\%SOURCE%.BIN %FW_SIZE_RECORD% 1

# 将二进制文件复制到下载目录中，然后使用 RESMERGER 工具合并文件到目标文件
# 将目标文件（%TARGET%）与资源配置文件（.\RES_CFG.INI）进行合并，并生成一个名为 1628 的新文件
COPY %OBJ%\%SOURCE%.BIN %DOWNLOAD%\%MIDDLE% >NUL
pushd %DOWNLOAD%
.%TOOL%\RESMERGER %TARGET% .\RES_CFG.INI 1628
popd	# 返回之前的目录

# 根据第二个参数的不同值选择调用不同的下载脚本（usboot.bat 或 romter.bat）
if "%2" == "usboot" (
	call .\script\usboot.bat
)

if "%2" == "romter" (
	call .\script\romter.bat
)

# 跳转到脚本结束标签
goto end
exit

# 代码/数据重叠错误处理，显示错误消息并暂停脚本执行
:ERR_OVERLAP
ECHO -------------------------------------------------------
ECHO  Build target fail!
ECHO  Code/Data overlap, please check %MAP%
ECHO -------------------------------------------------------
pause
exit
# IDE 环境未找到错误处理，显示错误消息并暂停脚本执行
:ERR_IDE_NOT_FOUND
ECHO -------------------------------------------------------
ECHO  Build target fail!
ECHO  Couldn't find Keil IDE tools in %KEIL%\
ECHO  Please configure IDE environment in ".\post.bat"
ECHO -------------------------------------------------------
pause
exit

:end	# 脚本结束标签
```

### 框架

> 主函数main函数在 `com_main.c` 里，里面进行调用 `__main()` 函数，主函数主要操作是：
>
> ```cpp
> globalInit();   // 进行全局初始化操作
> mainJobDo();    // 执行主要的任务操作
> ```

> 全局初始化放在 `global_init.c` 里【不需要改动】

> 定时器相关的在 `com_timer.c`，有定时器中断服务函数
>
> `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\kernel\inc\timer.h` 里面有定时器的定时时间设置，当前是 `5ms`

> 按键在 `app_key_scan.c`

> `app_ui_para.c` 是用户界面参数设置，`app_ui_para.h` 是头文件，有Excel生成的参数，里面有的是自动生成的不可以修改删除，有的是根据表格生成的但是没用到可以不用管，页面语言什么的
>
> `app_menu_micro.h` 是表格里参数的那些选项枚举类定义
>
> `appUiParaInit()`函数是参数初始化函数，可以看默认参数

> `host_func_opt.h` 是主机级功能的选项，很多宏可以选择是否要打开
>
> 有串口使能

> `app_ui_osd.c` 是处理用户界面元素、图形绘制、文本显示、菜单系统等

> 在 `os_ver.c`，用于存储版本信息
>
> ```cpp
> static UINT8 code verStr[] = "$os02";
> ```

> `app_init.c` 是应用程序初始化，`dev_init.c`是设备初始化相关(包含应用程序初始化)

> `app_status` 文件夹是存放UI界面的代码，主要在里面进行修改
>
> `app_sts_main.c` 是运行每一个界面状态主函数
>
> `app_menu_api.c` 是处理界面二级菜单以上的

> 开机的函数是 `hostDevInit()`，需要修改开机画面什么的话

> `download`文件夹里一般我们是使用 `A`资源文件夹，`B`资源文件夹暂时不用(具体情况具体分析)，`A`资源文件夹里面有 `JPG`文件夹，里面就是放相机的图片：开机图片等等，`WAV`文件夹里面是存放各种相机用到的声音，`download`文件夹还有一个 `RES_CFG.INI` 文件，里面是图片的ID，声音的ID：
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-07_22-35-12.webp)

> `app_main.h` 头文件里面有相机默认上电显示的界面宏定义：
>
> ```cpp
> #define STATE_DEFAULT	SP1K_MSG_STATE_TO_STILL_VIEW
> ```
>
> 还有页面状态枚举(appStateList_t)，还有页面状态ID枚举(appStateId_t)

> `iconPv.ini` 是界面图片坐标

> `os_msg.c` 系统消息相关函数

> `app_msg.h` 是消息类型枚举定义

> `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\inc\app\app_menu_tab.h` 这个文件是那些对话框ID应该





### 界面

- 主要文件

> 主要的几个界面
>
> |            文件名            |   主要内容   |                             路径                             |
> | :--------------------------: | :----------: | :----------------------------------------------------------: |
> |     app_sts_stillview.c      | 拍照页面视图 | `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_status\sts_view\` |
> |     app_sts_videoview.c      | 录像页面视图 | `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_status\sts_view\` |
> | app_sts_audiorec.c(`很少用`) | 音频页面视图 | `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_status\sts_view\` |
> |        app_ui_para.c         | 相机默认参数 | `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_para\` |
> |        `app_ui_osd.c`        |    ui页面    | `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_ui\` |
> |     app_sts_stillplay.c      | 拍照视图回放 | `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_status\sts_play\` |
> |     app_sts_videoplay.c      | 录像视图回放 | `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_status\sts_play\` |
> |        app_sts_menu.c        |     菜单     | `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_status\sts_menu\` |
>

- Excel表格含义

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-16_12-48-53.webp)

| 标号 |                  含义                   |                             备注                             |
| :--: | :-------------------------------------: | :----------------------------------------------------------: |
|  1   | 就是执行2前的判断，判断是否要进入什么的 | 在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_status\sts_menu\app_menu_active.c`<br>此函数不需要调用只需要在里面进行写功能 |
|  2   |           通过此函数进行设置            | 在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_status\sts_menu\app_menu_api.c`<br/>此函数不需要调用只需要在里面进行写功能 |
|  3   |        就是菜单里的顶部选项Mask         |            `STILL`：拍照选项<br>`SETUP`：设置选项            |
|  4   |         参数即表示这个功能选项          | 它的枚举类型可在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\inc\app\app_menu_micro.h` |
|  5   |         对应的参数不同类型图标          |                                                              |
|  6   |   如果此行不要则写入 `xxx`即表示删除    |                                                              |
|  7   |               对应3的名称               |                                                              |
|  8   |         子菜单，1级，2级，3级等         |                                                              |
|  9   |        对应的语言，后面还有也是         |                                                              |

- 新建一个选项需要改的地方是先在表格里面在合适地方插入一行，顺序需要注意，然后修改图标(如果有的话)，需要把图标资源加到 `download\resource\Icon\Icon2bit`(有的不是2bit，这个主要是数值小的颜色可能单一有别的8bit等)，然后需要显示就在 `download\resource\IconLayout` 里进行布局，然后执行 `menu.bat`，枚举那也需要改对应，如果用不到的则可以把值去掉也可以删除，类似：

```cpp
/*	Preview	AF Mode		*/
typedef enum _PRV_FOCUS
{
	PRV_AF_CENTER			= (unsigned char) 0x00,	// 顺序需要跟表格对应
	PRV_AF_SPOT				= (unsigned char) 0x01,
	PRV_AF_MAX,	// 这里不包含下面的
	PRV_AF_SUPER_MACRO,	// 没用到的房MAX后面，不赋值即可
	PRV_AF_MANUAL,
} PRV_FOCUS;
```



- 语言的修改需要注意除了上面还需要在脚本 `menu.bat` 里进行添加，按顺序都是英文名字

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-16_15-02-58.webp)



- 修改图片大小

先在 Excel表格添加，然后在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_status\sts_menu\app_menu_api.c` 里进行修改

> menuResizeSet()

在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\inc\app\app_menu_micro.h` 里枚举进行修改：

> _PRV_SIZE

在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_status\sts_play\app_sts_stillplay.c` 修改，这里的数据是按比例的，这个看那个表格选数据 `常用分辨率.txt`

> appPbImgResize()

在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_status\sts_view\app_sts_stillview.c`

> appStillQualitySet()

> appStillResolutionSet()

在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_ui\app_ui_osd.c`

> uiRemainPixInit()

> uiUpdateImgSize()



### 屏幕

屏幕驱动是 `ST7789V`

屏幕像素是：`320x240`

> 相关API在 `sp1k_osd_api.h` 里



#### 换屏

> 2024.3.29：此工程屏幕ST7789改成ili9340x

1. 复制一份同型号的，然后改名字为新的 `disp_ili9340x_BOE2.4_IPS.c` 改成 `ili9340x.c`
2. 修改 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\script\disp_install.bat` ，把名字改成我们新的
3. 修改 `ili9340.c`

- 把发来的驱动替换成自己的格式

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-19_11-19-11.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-19_11-20-36.webp)



- 修改数组

`static code UINT32 dispPwrOnCmdTbl[]` 里面就是放驱动，直接替换，需要注意如果没反应什么的需要看看同类型下的驱动多了哪些什么的加上去看看

```cpp
static code UINT32 dispPwrOnCmdTbl[] =
{
    // 新的驱动...直到下面这个注释地方之前的，需要看看是否有跟下面固定那些重复的就不要
    
    // window set
}
```

这里是这个屏幕换过程中需要在有的驱动文件里复制出来的

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-19_14-17-26.webp" style="zoom:67%;" />

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-19_14-17-40.webp" style="zoom:67%;" />

- 修改引脚

```cpp
__STATIC void dispOpPowerOn(void)
{
    // 直接把当前正在正常使用的屏幕驱动里的这个引脚配置(复位主要是)复制到这里替换即可
}
```







### 软件烧录步骤

1. 校验
2. 读取
3. 校验
4. 保存
5. 擦除
6. 加载
7. 编程
8. 校验



### 打包步骤

完成后执行menu.bat，编译生成，最后改名压缩发送



### 缩写

|       英文       |                           中文意思                           |
| :--------------: | :----------------------------------------------------------: |
| AF（Auto Focus） |                           自动对焦                           |
|       Q表        | 一种用于图像压缩的技术，它将图像中的像素值量化为更小的值，以减少图像数据的大小，从而实现压缩 |

### UI相关

> 相机UI的位置可以用 `IconLayout.exe`(在bin文件夹下)，下载安装即可，然后打开
>
> <img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-06_14-28-05.webp" style="zoom: 67%;" />
>
> <img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-06_14-29-04.webp" style="zoom:67%;" />
>
> <img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-06_14-29-39.webp" style="zoom:67%;" />

> `iCatchTek.xls` 表格里面是相关参数定义，这个修改然后运行 `Menu.bat` 再运行 `keil` 即可

> `app_osd_icon.h` 是存放UI ID的

> 资源图片需要检查图片尺寸对不对，然后用画图软件打开另存为一下即可



#### UI相关API

> void **uiUpdateEffect**(UINT8 x, UINT8 y, UINT8 attr)
>
> 在PV模式下刷新快照效果图标

> void **uiUpdateSnapMode**(UINT8 x, UINT8 y, UINT8 attr)
>
> 刷新PV模式下的拍摄模式图标

> void **uiSceneModeUpdate**(void)
>
> 更新场景模式图标显示

> void **uiUpdateFlashLed**(UINT8 x, UINT8 y, UINT8 attr)
>
> 根据当前闪光灯模式更新相应的图标显示状态



#### UI ICON

|      名称      |     ICON     |
| :------------: | :----------: |
| 近焦，自动对焦 | jinjiao.bmp  |
|      远焦      | yuanjiao.bmp |





### 大头贴

#### 修改大头贴

> 步骤

1. 在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\download\A\JPG` 里，直接替换图片，文件名字修改即可
2. 再在 `RES_CFG.INI` 里看看需不需要增加或者删除，改完需要执行一下脚本 `menu.bat`



### 大头贴处理



> 前期

- 常见格式

1. `320x240`
2. `640x480`
3. `960x720`



> 步骤

1. PS处理

客户一般是给处理好的，但是有的是处理得不够需要我们去处理一下

【准备工作】

创建3个文件夹，分别是 `320x240`，`320x240 CROP`，`320x240 CROP CPZP`

`320x240` 是存放我们PS处理好的大头贴

【1张演示】

把图片拖到PS里，先在右边把那个图片的锁解除先，点击 -> `图像` -> `图像大小`，进行修改(快捷键 `Alt + I + I`)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-14_22-33-17.webp)

点击右下角 `+` 图标新建新图层，然后点击左边竖直工具栏的 `设置前景色` 工具(没有这个需要右键那点那个 `...` 进行显示)，把新建图层颜色修改为 `#8c8c8c`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-14_23-00-50.webp)

然后 `ctrl+A` 全选，再按 `Alt + Delete` (全部填充)，然后把图层1拖到下面

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-14_23-05-50.webp)

然后按住 `ctrl` 键再点击这两个图然后右键 `合并图层`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-14_23-04-21.webp)

然后就处理完成了

【快速操作】

使用动作可以快速完成操作，首先需要点击 -> `窗口` -> `动作`，这样就显示动作栏了，先把一张需要搞的图片加载进来，点击 -> `+` 创建新动作(然后它就开始录制了，然后就开始按照上面那样操作一次流程)，录制完成点击那个正方形结束录制，然后准备开始脚本：

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-14_23-20-13.webp" style="zoom:67%;" />

选择待处理的图片文件夹，点击确定即可

【另存为bmp】

打开刚刚处理完的文件夹，全选图片(选择12张)然后右键编辑，画图工具打开，然后另存为bmp

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-14_23-39-49.webp" style="zoom:67%;" />



2. 处理生成GPZP文件

打开大头贴制作工具

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-14_23-54-37.webp" style="zoom:67%;" />

点击 `file` ，点击 `open project`，选择这个工具下的工程 `GP420.get`(这个工程自己新建的为了方便添加图片)，然后进行添加图片

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-14_23-59-49.webp" style="zoom:67%;" />

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-15_00-00-37.webp" style="zoom: 67%;" />

加载完则点击 `Stage Mode` ，双击图片加载进去，然后右键 `Stage Text` ，选择 `Output`

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-15_00-06-11.webp)

然后进行输出，选择格式是 `Bitmap Mode`，然后点击保存，保存到文件夹然后单击确定即可

|   尺寸    |    格式     |
| :-------: | :---------: |
| `320x240` | Bitmap Mode |

<img src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-15_00-08-50.webp" style="zoom:50%;" />

【执行脚本】

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-15_00-13-27.webp)

执行完就可以进行重命名，看看之前的资源里面的命名是怎么样的，参考一下，改一下名字就行了把处理完的最终放在 `320x240` 文件夹里

3. 更新



### 特殊920x720

要处理这种的，需要切，分成三份就是切两刀，可以一组一组来，也可以一次性加载

1. 打开 `config.exe`
2. 点击 `+` ，全选加载进去，然后点击 `横向切刀`，刀数 `2`，格式选择 `bmp`，前缀随便写，这里我写 `PF`，存储路径选择一个用来保存的文件夹，点击 `开始分割`，分割完即可开始上面的大头贴处理流程
3. 注意这里的输出格式是 `GP420`







### 充电IC-4064M

看原理图好像是 `CL4064M`

> 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-10_17-06-52.webp)



### 降压/稳压



> 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-10_17-11-02.webp)



### 闪存EN25F32

EN25F32 是一款 32M 位（4096K 字节）串行闪存，具有先进的写保护机制，可通过高速 SPI 兼容总线访问。使用页面编程指令，存储器每次可编程 1 至 256 字节

`允许一次进行单扇区/块或全芯片擦除操作`

`可以使用SPI 模式 0 和模式 3`

`32 M 位/4096 K 字节/16384 页`，`每页256 Byte`

`100MHz 时钟频率`

`通过 WP# 引脚启用/禁用保护功能`

`页面编程时间：典型值为 1.3ms`，`扇区擦除时间：典型值 90ms`，`块擦除时间：典型值 500ms`，`芯片擦除时间：典型值 25 秒`

`可锁定 512 字节 OTP 安全扇区`

`通过软件对全部或部分内存进行写保护`

`只能1写0`





> SPI时序

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-10_19-40-05.webp)



> 工程里几个主要文件

`spi.c`里有相关地址宏定义





### 看门狗





### SD卡

程序里有进行判断的，不插卡的话是进不去菜单，可以屏蔽就可以进入了，具体在： `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_status\sts_main\app_sts_main.c`

```diff
if((appSDPlugStatusGet() == 0) && (sp1kDiskTypeGet() == DEV_TYPE_DISK_SPI) && (sp1kDosRamStsGet() == FALSE))
{
    if(appCurrStateGet() !=	APP_STATE_MENU)
    {
-        if(msg == SP1K_MSG_KEY_PRESS_OK || msg == SP1K_MSG_KEY_PRESS_SNAP)
+		 if(msg == SP1K_MSG_KEY_PRESS_SNAP)
            msg = SP1K_MSG_CARD_PLUG_OUT;
    }
}
```



### 按键

这个芯片的AD是 `10` 位的，也就是计算AD值是：`实际电压/3.3V*1023`

> 相关枚举/ 结构体

```cpp
keyStatus_e	// 按键状态枚举
keyType_e 	// 按键类型枚举  
keyMsg_s    // 按键消息结构体	
keyAttrAdc_s // ADC 按键属性结构体   
keyAttrGpio_s	// GPIO 按键属性结构体  
keyCtrlAdc_s    // ADC 按键控制结构体
keyCtrlGpio_s    // GPIO 按键控制结构体
keyUnitAdc_s    // ADC 按键单元结构体
keyUnitGpio_s    // GPIO 按键单元结构体
battUnitAdc_s    // 电池电量 单元结构体
scanTag_s    // 总体单元模块结构体
```

```cpp
/*------------------------相关函数-----------------------------*/

/*
按键初始化函数
通过【HAL_GlobalDGPIOModeGet】判断IC版本进行选择对应的硬件接口
*/
void keyScanInit(void)
    
/*
按键总扫描函数
放在定时器0里，10ms检测一次
里面进行ADC-A,ADC-B,GPIO/DGPIO 按键的检测
*/    
void keyScan(void)    
    
/*
GPIO/DGPIO按键扫描检测函数

	进行按键的动作判断还有对应动作是否唤醒屏幕背光,里面主要分为4个操作(假设按下是低电平			(gpioPrsFlag=0x00)，默认是上拉情况下)：
	【1. 无按键操作】
		当前按键为高电平，上一个按键状态是释放状态，则此次为无按键操作	
	【2. 松开操作】
		当前按键为高电平，上一个按键状态不是释放状态，则此次为松开操作，发送松开消息
	【3. 按下操作】
		当前按键为低电平，上一个按键状态是释放状态，则此次为按下操作，发送按下消息
	【4. 长按操作】
		当前按键为低电平，上一个按键状态是按下状态，按键使能，等长按计数值减到0则发送长按消息

*/    
static void keyScanGpioParsing(keyUnitGpio_t *pGpio)
    -> static void keyScanGpioValParsing(UINT8 gpioVal, UINT8 gpioChn, keyUnitGpio_t *pGpio, UINT8 gpioPrsFlag)

/*
ADC按键扫描函数，根据采样值判断按键的状态（按下、释放、长按），并通过消息机制发送相应的消息，ADC-A和ADC-B都是通过调用这个函数进行获取ADC值(前提是调用这个函数前选择对应的ADC通道(0/2))

	获取对应的通道ADC-x的AD	值
	
	ADC值滤波(通过对连续两次采样值进行比较，并计算差值，如果差值大于预设的阈值ADC_SAMPLE_ERR_LIMIT，则	 认为采样出现错误，否则取两次采样值的平均值作为滤波后的结果)

判断AD按键类型，是ADC-B类型的话则进行对应的AD值处理

【1. 无按键操作】
【2. 松开操作】
上一个键值是波动(即是按下状态)，如果当前键值也是波动，则什么都不操作(无操作)，如果此次不是波动(松开)，如果该按键使能，设置释放消息，激活的按键索引置-1
【3. 按下操作】
有按键波动，长按计数值赋值置1，发送消息：设置为按键按下消息
【4. 长按操作】
有按键波动且长按计数值为真，如果按键使能了，长按计数值--，减到0就进行长按计数值重新设置，如果长按按键消息不为空，就发送按键长按消息(背光关闭下暂时只用到电源长按，其他长按消息都为空)


*/
static void keyScanAdcParsing(keyUnitAdc_t *pAdc)
    -> UINT16  sp1kADCValueSnapIntr(void)
	-> UINT16 adc_filter_noise(UINT16 value, UINT8 channel)
    
/*
解析ADC采样值是否匹配宏定义的AD值和误差值
*/   
static UINT8 keyScanAdcValParsing(UINT16 AdcValue, keyUnitAdc_t *pAdc, UINT8 *AdcIdx)    
```



### 其他

> 拍照步骤：AF按键按下发送【SP1K_MSG_KEY_PRESS_AF】在里面发送【SP1K_MSG_SYS_AF_START】消息，然后到【SP1K_MSG_SYS_AF_CAL】在里面成功则发送【SP1K_MSG_SYS_AF_SUCCESS】(失败则发送【SP1K_MSG_SYS_AF_FAIL】)，会进行【SP1K_MSG_SYS_AF_BACK_FAR】





## 配置



### 总的IO分布/数据

- GPIO

|   IO   |                   描述                   |
| :----: | :--------------------------------------: |
| GPIO0  |    【DA_RESET】摄像头复位,低电平复位     |
| GPIO1  |  【AF】AF(自动对焦)电源控制,低电平导通   |
| GPIO2  |   【XIAO_RESET】小镜头复位,低电平复位    |
| GPIO3  |      【USB_DAT】USB检测,插入高电平       |
| GPIO4  | 【LED_BUSY】板子上的蓝色忙碌灯，低电平亮 |
| GPIO5  |        【LED_EN】闪光灯,高电平亮         |
| GPIO6  |     【SER_WPn】 SPI写保护,低电平有效     |
| GPIO7  |    【TFT_REST】 显示屏复位,低电平有效    |
| GPIO8  |     【AF_key】 功放使能，按下低电平      |
| GPIO9  |      【BL_ON】显示屏背光,高电平使能      |
| GPIO10 |             【Watch】看门狗              |

- DGPIO

|   IO   |               描述                |
| :----: | :-------------------------------: |
| DGPIO0 | 【DGPIO0】SD卡检测,检测到是低电平 |
| DGPIO1 |       【W1 KEY】按下低电平        |
| DGPIO2 | 【SHUTTER KEY】拍照键,按下低电平  |
| DGPIO3 |       【T1 KEY】按下低电平        |

- SARIN0

|   IO   |         描述         |
| :----: | :------------------: |
| PWR_ON | 【PWR_ON KEY】电源键 |

- SARIN2

|   IO   |         描述         |
| :----: | :------------------: |
| MODE1  | 【MODE1 KEY】模式键  |
|  DEL1  |  【DEL1 KEY】删除键  |
| DOWN1  | 【DOWN1 KEY】向下键  |
| RIGHT1 | 【RIGHT1 KEY】向右键 |
| BACK1  | 【BACK1 KEY】返回键  |
|  UP1   |  【UP1 KEY】向上键   |
|  OK1   |  【OK1 KEY】向下键   |

- 电池电压(仅供参考)

```cpp
电压 对应AD值
4.2 	260
4.1 	245
4.0 	240
3.9 	233
3.8 	226
3.7 	220
3.6 	217
3.5 	210
```

- 不同状态下的按键AD值(测得电压 -- 对应AD值)仅供参考此工程不是按照下面

```cpp
【USB】
LEFT KEY: 1.55V -- 430
DEL KEY: 2.6V -- 840
OK1 KEY: 3.1V -- 1023
PWR_ON KEY: 2.0V -- 622
【电池最大电压时4.2V】
LEFT KEY: 1.55V -- 400
DEL KEY: 2.6V -- 810
OK1 KEY: 3.1V -- 1023
PWR_ON KEY: 2.0V -- 600
【电池最小电压时3.5V】
LEFT KEY: 1.55V -- 350
DEL KEY: 2.6V -- 760
OK1 KEY: 3.1V -- 1023
PWR_ON KEY: 2.0V -- 540   
```



### 镜头

> 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-08_20-54-57.webp)

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-09_14-26-31.webp)



|  网络标号  | 对应引脚 | 设置 |
| :--------: | :------: | :--: |
|  DA_RESET(大镜头)  |  GPIO0  | GPIO模式，输出 |
| ~~XIAO_RESET(小镜头)~~ |  ~~GPIO2~~  | ~~GPIO模式，输出~~ |
| AF(自动对焦电源控制) | GPIO1 | GPIO模式，输出 |

此处小镜头没用到



> 步骤

1. 在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\script\` 下的 `front_install.bat` 脚本文件，编辑模式下可以看到这里有镜头的型号，通过改这里可以换不同镜头：

   ```cpp
   set "CUSTOM_DRIVER=OV_OV5647_RAW"	# 在front文件夹下有不同型号的文件夹，直接把文件名复制过来即可
   ```

   在 `E:\work\240226 新板 按键 屏显 偏红 L 开关机 曝光\CDAF\drivers\front` 文件夹下有很多型号可以进行选择

   {% note red 'fas fa-fan' flat %}

   这个 bat 脚本它里面有很多固定参数的，比如Keil的安装路径什么的都是写死的所以需要注意，还有其他文件的路径也是最好不要动，还有对应镜头型号的 `.c` 文件也是名字是固定的不要乱改，其他脚本也是类似注意这些细节

   {% endnote %}
   
2. 找到对应的 `.c` ，我的是 `front_ov_ov5647_raw.c`，里面一般只需要改大镜头的复位引脚即可(如果有用到小镜头也在这下面进行配置)，也就是在下面函数：

```cpp
static void frontBeforePowerOn(void)
{
    /* 复位 */
	gpioByteFuncSet(GPIO_BYTE_GEN0, GPIO_PIN_1, GPIO_PIN_1);  // 设置 GPIO 功能 -- GPIO
	gpioByteDirSet(GPIO_BYTE_GEN0, GPIO_PIN_1, GPIO_PIN_1);   // 设置 GPIO 方向 -- 输出
	gpioByteOutSet(GPIO_BYTE_GEN0, GPIO_PIN_1, GPIO_PIN_1_SET);   // 设置 GPIO 输出 -- 高电平
	sp1kHalWait(20);  // 等待一段时间
	
	gpioByteOutSet(GPIO_BYTE_GEN0, GPIO_PIN_1, GPIO_PIN_RESET);   // 设置 GPIO 输出 -- 低电平
	sp1kHalWait(100);  // 等待一段时间
	
	gpioByteOutSet(GPIO_BYTE_GEN0, GPIO_PIN_1, GPIO_PIN_1_SET);   // 设置 GPIO 输出 -- 高电平
	sp1kHalWait(20);  // 等待一段时间
}
```

改完就也把文件夹里的keil程序编译一遍，如果有加自己的头文件需要把头文件路径也加进来先(注意 `drv_sensor.c` 是生成的不需要管！)

3. 自动对焦电源控制引脚的配置在 `app_dev_disp.c` 里的 `appAFCtrl()` 函数



### USB

> 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-09_17-51-46.webp)

| 网络标号 | 对应引脚 |      设置      |
| :------: | :------: | :------------: |
| USB_DAT  |  GPIO3   | GPIO模式，输入 |

> 步骤

1. USB插入检测 在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\kernel\src\api\sp1kGpio` 下的 `sp1k_gpio_api.c` 里，只需要设置对应上下拉即可

```cpp
void sp1kUSB_PlugCfg(void)
{
#if USE_PKG_DEDICATE_PIN
    //sp1kPullSelSet(3, 0x01, 0x00);
    sp1kPullEnSet(4, 0x10, 0);  // 使能内部上下拉 -- 不使能
    pkgDedicateGpioCfg(PKG_DEDICATE_PIN_USB_PLUG, &gpioByteIdUsbPlug, &gpioBitMskUsbPlug, &gpioPolarityUsbPlug, 0);	// 
#endif
}
```



2. `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\script` 下的 `package_install.bat` 里面进行修改主控操作：

```cpp
set "CUSTOM_DRIVER=PACKAGE_1627"
```

这个可以到 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\drivers\package` 下选择对应的，直接复制文件名称即可，然后替换完需要打开对应的 `.c` 文件，里面进行修改：

```cpp
code pkgDedicateGpio_t pkgDedicateGpioTbl[] =
{
    // 略...
    {PKG_DEDICATE_PIN_USB_PLUG,   	GPIO_BYTE_GEN0,  	GPIO_PIN_4, 			ACTIVE_HIGH}
    // 略...
}
```

`drv_package.c` 文件是自动生成的！



### LED

> 硬件

板子上的蓝色忙碌指示灯

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-10_21-24-21.webp)

闪光灯

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-10_21-26-57.webp)

| 网络标号 | 对应引脚 |      设置      |
| :------: | :------: | :------------: |
| LED_BUSY |  GPIO4   | GPIO模式，输出 |
|  LED_EN  |  GPIO5   | GPIO模式，输出 |



> 步骤

1. 配置蓝色灯，在 `app_dev_disp.c` 里

```cpp
/**
* @param    falg: LED_BUSY_ON 亮 LED_BUSY_OFF 灭
* @retval   None
* @brief    忙指示灯控制
**/
void app_set_led(UINT8 falg)
{
#if !DBG_MODE
    gpioByteFuncSet(GPIO_BYTE_GEN0, GPIO_PIN_5, GPIO_PIN_5);                            // gpio初始化
    gpioByteOutSet(GPIO_BYTE_GEN0, GPIO_PIN_5, falg ? GPIO_PIN_RESET : GPIO_PIN_5_SET); // 输出电平 --- LED_BUSY_ON->低电平 LED_BUSY_OFF->高电平
    gpioByteDirSet(GPIO_BYTE_GEN0, GPIO_PIN_5, GPIO_PIN_5);                             // 方向
#endif
}
```

2. 配置闪光灯，也在 `app_dev_disp.c` 里

```cpp
/**
* @param    flag: SPARK_LED_ON--亮 SPARK_LED_OFF--灭
* @retval   None
* @brief    闪光灯控制
**/
void appFlashLedSet(UINT8 flag) 
{
	// gpio 5
	sp1kPullEnSet(4,0x40,0x00);
	gpioByteFuncSet(GPIO_BYTE_GEN0, GPIO_PIN_6, GPIO_PIN_6);
	gpioByteDirSet(GPIO_BYTE_GEN0, GPIO_PIN_6, GPIO_PIN_6);
	gpioByteOutSet(GPIO_BYTE_GEN0, GPIO_PIN_6, flag ? GPIO_PIN_6_SET : GPIO_PIN_RESET);
}
```





### Flash闪存

> 硬件

主要是控制写保护引脚

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-10_19-22-49.webp)

| 网络标号 | 对应引脚 |      设置      |
| :------: | :------: | :------------: |
| SER_WPn  |  GPIO6   | GPIO模式，输出 |



1. 检查宏 `SUPPORT_SPI_WRITE_CONTROL` 有没有置1，在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\inc\customization\host_func_opt.h` 里
2. 在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_dev\app_dev_disp.c` 里找到下面函数在里面进行修改：

```cpp
#if SUPPORT_SPI_WRITE_CONTROL
/**
* @param    falg: FLASH_SPI_LOCK--使能 FLASH_SPI_UNLOCK--失能
* @retval   None
* @brief    SPI写保护引脚配置
**/
void appSetGpio6SpiWP(UINT8 falg)
{
    gpioByteFuncSet(GPIO_BYTE_GEN0, GPIO_PIN_7, GPIO_PIN_7);
    gpioByteOutSet(GPIO_BYTE_GEN0, GPIO_PIN_7, falg ? GPIO_PIN_7_SET : GPIO_PIN_RESET);
    gpioByteDirSet(GPIO_BYTE_GEN0, GPIO_PIN_7, GPIO_PIN_7);
}
#endif
```



### 屏幕

> 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-10_20-14-48.webp)



| 网络标号 | 对应引脚 |      设置      |
| :------: | :------: | :------------: |
| TFT_REST |  GPIO7   | GPIO模式，输出 |
|  BL_ON   |  GPIO9   | GPIO模式，输出 |



> 步骤

1. 打开配置脚本文件 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\script\disp_install.bat`，修改对应的屏幕型号：

```bash
set "CUSTOM_DRIVER=hsd2.4ips_st7789v"	# "disp_" 前缀不需要写
```

其他型号可在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\drivers\display\lcm` 里进行选择

2. 找到对应的 `.c` 文件进行修改，这里是 `disp_hsd2.4ips_st7789v.c`，主要是修改显示屏复位引脚配置部分：

```cpp
__STATIC void dispOpPowerOn(void)
{
    // 略...
    
/*-------------------- USER CODE: Custom Begin --------------------*/

    /* gpio 7 REST */
    gpioByteFuncSet(GPIO_BYTE_GEN0, GPIO_PIN_8, GPIO_PIN_8);    // 初始化GPIO
    gpioByteDirSet(GPIO_BYTE_GEN0, GPIO_PIN_8, GPIO_PIN_8);     // 方向 -- 输出
    gpioByteOutSet(GPIO_BYTE_GEN0, GPIO_PIN_8, GPIO_PIN_8_SET); // 拉高
    sp1kHalWait(50);
    gpioByteOutSet(GPIO_BYTE_GEN0, GPIO_PIN_8, GPIO_PIN_RESET); // 拉低
    sp1kHalWait(110);
    gpioByteOutSet(GPIO_BYTE_GEN0, GPIO_PIN_8, GPIO_PIN_8_SET); // 再拉高，完成复位
    sp1kHalWait(100);

    /*-------------------- USER CODE: Custom End --------------------*/    
    
    // 略...
}
```

3. 有的屏幕可能还有 `TE` 引脚(用于控制数据的传输和显示的，用于控制显示器的垂直同步信号，以确保数据在屏幕上的正确显示和刷新)，有的话只需要打开 `#if` 即可，如果屏幕没有这个则置 `0`，然后改一下里面的引脚即可，改数字8

```cpp
#if 1
XBYTE[REG_Disp_GpioSel1] |= 0x01 << (8 & 0x07); //set DGPIO 8 as TE pin in
XBYTE[REG_Disp_GpioOutEn1] &= ~(0x01 << (8 & 0x07));
XBYTE[REG_Disp_PhsSel_Polar] |= 0x10;
XBYTE[REG_Disp_LcmVSUpd_DmaEn] |= 0x03;
#endif
```

`drv_panel.c` 是自动生成的！

4. 屏幕背光BL_ON的配置下面函数里：

```cpp
/**
* @param    status: LCD_LED_ON -- 使能 LCD_LED_OFF -- 失能
* @retval   None
* @brief    设置 屏幕LCD 背光的状态
**/
void app_set_lcd_backlight_status(UINT8 status)
{
    /* GPIO 9 */ 

    // 设置 lcd_backlight_status 变量为 status 的布尔值（1 或 0）
    lcd_backlight_status = (status ? LCD_LED_ON : LCD_LED_OFF);

    // 如果 lcd_backlight_status 为真（开启状态）
    if (lcd_backlight_status)
    {
        // 设置 GPIO 为功能模式，使能对应引脚的输出功能
        gpioByteFuncSet(GPIO_BYTE_GEN1, GPIO_PIN_2, GPIO_PIN_2);
        // 设置 GPIO 为输出模式，使能对应引脚的输出功能
        gpioByteDirSet(GPIO_BYTE_GEN1, GPIO_PIN_2, GPIO_PIN_2);
        // 设置 GPIO 输出高电平，开启 LCD 背光
        gpioByteOutSet(GPIO_BYTE_GEN1, GPIO_PIN_2, GPIO_PIN_2_SET);

// 如果支持面板保护功能，则执行关闭 LCD 背光保护的操作
#if SUPPORT_PANEL_PROTECT
        app_set_close_lcd_backlight_time();
#endif

        // 重新加载自动关机时间
        appAutoOffTimeReload();
    }
    // 如果 lcd_backlight_status 为假（关闭状态）
    else
    {
        // 设置 GPIO 为功能模式，使能对应引脚的输出功能
        gpioByteFuncSet(GPIO_BYTE_GEN1, GPIO_PIN_2, GPIO_PIN_2);
        // 设置 GPIO 为输出模式，使能对应引脚的输出功能
        gpioByteDirSet(GPIO_BYTE_GEN1, GPIO_PIN_2, GPIO_PIN_2);
        // 设置 GPIO 输出低电平，关闭 LCD 背光
        gpioByteOutSet(GPIO_BYTE_GEN1, GPIO_PIN_2, GPIO_PIN_RESET);
    }
}
```



### 按键

> 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-10_20-48-11.webp)

AD0采集默认是采集到是

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-10_21-13-14.webp)

AD2采集默认是采集到是3.3V，即没有按键按下，其他的如下(还是以实际测试为准这个只是手算)

| 按键  |   对应电压计算(有误差正常)   |
| :---: | :--------------------------: |
| MODE  | `3.3V * 1000K / 1100K = 3V`  |
|  DEL  | `3.3V * 270K / 370K = 2.4V`  |
| DOWN  | `3.3V * 150K / 250K = 1.98V` |
| RIGHT | `3.3V * 82K / 182K = 1.48V`  |
| BACK  | `3.3V * 43K / 143K = 0.99V`  |
|  UP   | `3.3V * 20K / 120K = 0.55V`  |
|  OK   |    `3.3V / 100k = 0.033V`    |

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-10_21-14-07.webp)



> 步骤

`注意`:当前使用的宏是：

```cpp
#define _HW_EVB_				0x00
```



1. `AF_key`配置  在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_ui\app_key_scan.c`，DGPIO相关的也是在这下面函数：

```cpp
static void keyScanGpioParsing(keyUnitGpio_t *pGpio)
{
/*-------------------- USER CODE: Custom Begin --------------------*/

    gpioChn = 0; // 读取W1，即DGPIO1
    curKeyVal = (gpioVal & GPIO_PIN_2);
    if (*pGpio->keyAttr[gpioChn].pKeyEn)    // 判断按键是否使能
    {
        // 参数4是按下的电平状态，具体看原理图
        keyScanGpioValParsing(curKeyVal, gpioChn, pGpio, 0x00);
    }

    gpioChn = 1; // 读取SHUTTER，即DGPIO2
    curKeyVal = (gpioVal & GPIO_PIN_3);
    if (*pGpio->keyAttr[gpioChn].pKeyEn)
    {
        keyScanGpioValParsing(curKeyVal, gpioChn, pGpio, 0x00);
    }

    gpioChn = 2; // 读取T1，即DGPIO3
    curKeyVal = (gpioVal & GPIO_PIN_4);
    if (*pGpio->keyAttr[gpioChn].pKeyEn)
    {
        keyScanGpioValParsing(curKeyVal, gpioChn, pGpio, 0x00);
    }

    /* GPIO扫描 */
    gpioChn = 3; // 读取AF，即GPIO8
    if (*pGpio->keyAttr[gpioChn].pKeyEn)
    {
        /* gpio 8 */
        sp1kPullEnSet(5, 0x02, 0x02);   // 使能内部上下拉 --- gpio功能
        sp1kPullSelSet(3, 0x20, 0x20);  // 使能内部上拉
        HAL_GpioByteDirSet_Intr(HAL_GPIO_BYTE_GEN1, GPIO_PIN_1, 0); // GPIO中断 --- 将GPIO 设置为输入
        gpioVal = gpioByteInGet(HAL_GPIO_BYTE_GEN1, GPIO_PIN_1, 1); // 获取电平输入状态

        keyScanGpioValParsing(gpioVal, gpioChn, pGpio, 0x00);
    }

/*-------------------- USER CODE: Custom End --------------------*/   
}
```

2. 按键数量，哪几个按键，按键AD值宏定义是在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\inc\customization\key_scan.h`里：

```cpp
/* ADC-A(SARIN0)按钮AD值定义(1023 - 要进行判断的AD值 = 实际AD值) */
#define SP1K_ADC_BTN_A_S1 1023 // power(1023-1024=0)
/* ADC-B(SARIN2)按钮AD值定义(1023 - 要进行判断的AD值 = 实际AD值) */
#define SP1K_ADC_BTN_B_S1 559  // RIGHT1(1023-559=464)
#define SP1K_ADC_BTN_B_S2 860  // UP1(1023-860=163)
#define SP1K_ADC_BTN_B_S3 715  // BACK1(1023-715=308)
#define SP1K_ADC_BTN_B_S4 93   // MODE1(1023-93=930)
#define SP1K_ADC_BTN_B_S5 409  // DOWN1(1023-409=614)
#define SP1K_ADC_BTN_B_S6 1023 // OK1(1023-1023=0)
#define SP1K_ADC_BTN_B_S7 275  // DEL1(1023-275=748)

/* ADC-A(SARIN0) AD值对称范围*/
#define SP1K_ADC_BTN_DEV_A_S1 100
/* ADC-B(SARIN2) AD值对称范围*/
#define SP1K_ADC_BTN_DEV_B_S1 50
#define SP1K_ADC_BTN_DEV_B_S2 45
#define SP1K_ADC_BTN_DEV_B_S3 50
#define SP1K_ADC_BTN_DEV_B_S4 50
#define SP1K_ADC_BTN_DEV_B_S5 50
#define SP1K_ADC_BTN_DEV_B_S6 45
#define SP1K_ADC_BTN_DEV_B_S7 50

/* ADC-A(SARIN0) 按键数量*/
#define SP1K_ADC_BTN_A_NUM 1
/* ADC-B(SARIN2) 按键数量*/
#define SP1K_ADC_BTN_B_NUM 7

/*ADC 按键总数量(ADC-A + ADC-B)*/
#define SP1K_ADC_BTN_NUM (SP1K_ADC_BTN_A_NUM + SP1K_ADC_BTN_B_NUM)

/*GPIO/DGPIO 按钮数量*/
#define SP1K_GPIO_BTN_NUM 4 // 分别是W1，SHUTTER，T1，AF(+1 only for 1626 evb)

// 板子使用的按键总数
#define SP1K_BTN_NUM (SP1K_ADC_BTN_NUM + SP1K_GPIO_BTN_NUM)
```

上面这些是按照顺序的，可参考  `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_ui\app_key_scan.c` 里的下面这个数组，从上到下

```cpp
/*根据宏定义选择定义 ADC_A设备表 静态数组*/
static UINT16 code keyAdcAValDevTbl[SP1K_ADC_BTN_A_NUM] = 
{
    SP1K_ADC_BTN_DEV_A_S1
};
/*根据宏定义选择定义 ADC_B设备表 静态数组*/
static UINT16 code keyAdcBValDevTbl[SP1K_ADC_BTN_B_NUM] = 
{
    SP1K_ADC_BTN_DEV_B_S1,
    SP1K_ADC_BTN_DEV_B_S2,
    SP1K_ADC_BTN_DEV_B_S3,
    SP1K_ADC_BTN_DEV_B_S4,
    SP1K_ADC_BTN_DEV_B_S5,
    SP1K_ADC_BTN_DEV_B_S6,
    SP1K_ADC_BTN_DEV_B_S7,
};

/*根据宏定义选择定义 ADC_A值 静态数组*/
static UINT16 code keyAdcAVal[SP1K_ADC_BTN_A_NUM] = 
{
    SP1K_ADC_BTN_A_S1
};
/*根据宏定义选择定义 ADC_B值 静态数组*/
static UINT16 code keyAdcBVal[SP1K_ADC_BTN_B_NUM] = 
{
    SP1K_ADC_BTN_B_S1,
    SP1K_ADC_BTN_B_S2,
    SP1K_ADC_BTN_B_S3,
    SP1K_ADC_BTN_B_S4,
    SP1K_ADC_BTN_B_S5,
    SP1K_ADC_BTN_B_S6,
    SP1K_ADC_BTN_B_S7,
};


/*按键消息的定义数组*/
static keyMsg_t code keyMsg[SP1K_BTN_NUM] =
{
    /*ADC A(SARIN0) button msg*/
    
    {SP1K_MSG_KEY_PRESS_POWER, SP1K_MSG_KEY_REPEATE_POWER, SP1K_MSG_KEY_RELEASE_POWER}, // 【power】

    /*ADC B(SARIN2) button msg*/
    
    {SP1K_MSG_KEY_PRESS_PB, SP1K_MSG_KEY_REPEATE_PB, SP1K_MSG_KEY_RELEASE_PB}, // 【RIGHT1】
    {SP1K_MSG_KEY_PRESS_UP, SP1K_MSG_KEY_REPEATE_UP, SP1K_MSG_KEY_RELEASE_UP},       // 【UP1】
    {SP1K_MSG_KEY_PRESS_BACK, SP1K_MSG_KEY_REPEATE_BACK, SP1K_MSG_KEY_RELEASE_BACK}, // 【BACK1】
    {SP1K_MSG_KEY_PRESS_MODE, SP1K_MSG_NULL, SP1K_MSG_KEY_RELEASE_MODE},             // 【MODE1】
    {SP1K_MSG_KEY_PRESS_DOWN, SP1K_MSG_KEY_REPEATE_DOWN, SP1K_MSG_KEY_RELEASE_DOWN}, // 【DOWN1】
    {SP1K_MSG_KEY_PRESS_OK, SP1K_MSG_NULL, SP1K_MSG_KEY_RELEASE_OK},                 // 【OK1】
    {SP1K_MSG_KEY_PRESS_MENU, SP1K_MSG_KEY_REPEATE_MENU, SP1K_MSG_KEY_RELEASE_MENU}, // 【DEL1】

    /*GPIO(GPIO和DGPIO) button msg*/
    
    {SP1K_MSG_KEY_PRESS_ZOOM_OUT, SP1K_MSG_KEY_REPEATE_ZOOM_OUT, SP1K_MSG_KEY_RELEASE_ZOOM_OUT}, // 【w】
    {SP1K_MSG_KEY_PRESS_SNAP, SP1K_MSG_KEY_REPEATE_SNAP, SP1K_MSG_KEY_RELEASE_SNAP},             // 【shutter】
    {SP1K_MSG_KEY_PRESS_ZOOM_IN, SP1K_MSG_KEY_REPEATE_ZOOM_IN, SP1K_MSG_KEY_RELEASE_ZOOM_IN},    // 【t】
    {SP1K_MSG_KEY_PRESS_AF, SP1K_MSG_NULL, SP1K_MSG_NULL},	// 【AF功放使能】
};	
```

3. 按键注册消息在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\inc\app\app_msg.h`，主要是下面这个枚举：

```cpp
typedef enum btnMsgList_e
{
    SP1K_MSG_START_BTN = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0000, // 开始按钮消息

    /* UI按键消息 */

    SP1K_MSG_KEY_PRESS_S1 = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0100,       // S1按键按下消息
    SP1K_MSG_KEY_PRESS_S2 = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0101,       // S2按键按下消息
    SP1K_MSG_KEY_PRESS_MENU = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0102,     // 菜单按键按下消息
    SP1K_MSG_KEY_PRESS_UP = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0103,       // 上按键按下消息
    SP1K_MSG_KEY_PRESS_DOWN = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0104,     // 下按键按下消息
    SP1K_MSG_KEY_PRESS_LEFT = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0105,     // 左按键按下消息
    SP1K_MSG_KEY_PRESS_RIGHT = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0106,    // 右按键按下消息
    SP1K_MSG_KEY_PRESS_OK = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0107,       // 确认按键按下消息
    SP1K_MSG_KEY_PRESS_TELE = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0108,     // 变焦放大按键按下消息
    SP1K_MSG_KEY_PRESS_WIDE = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0109,     // 变焦缩小按键按下消息
    SP1K_MSG_KEY_PRESS_DISP = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x010a,     // 显示按键按下消息
    SP1K_MSG_KEY_PRESS_F1 = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x010b,       // F1按键按下消息
    SP1K_MSG_KEY_PRESS_F2 = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x010c,       // F2按键按下消息
    SP1K_MSG_KEY_PRESS_PB = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x010d,       // 回放按键按下消息
    SP1K_MSG_KEY_PRESS_POWER = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x010e,    // 电源按键按下消息
    SP1K_MSG_KEY_PRESS_MODE = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x010f,     // 模式按键按下消息
    SP1K_MSG_KEY_PRESS_SNAP = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0110,     // 快照按键按下消息
    SP1K_MSG_KEY_PRESS_SENSOR = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0111,   // 传感器按键按下消息
    SP1K_MSG_KEY_PRESS_AF = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0112,       // 自动对焦按键按下消息
    SP1K_MSG_KEY_PRESS_ZOOM_IN = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0113,  // 放大按键按下消息
    SP1K_MSG_KEY_PRESS_ZOOM_OUT = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0114, // 缩小按键按下消息
    SP1K_MSG_KEY_PRESS_BURST = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0115,    // 连拍按键按下消息
    SP1K_MSG_KEY_PRESS_BACK = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0116,     // 返回按键按下消息
    SP1K_MSG_KEY_PRESS_MAX = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x01ff,      // 按键按下消息最大值

    SP1K_MSG_KEY_RELEASE_S1 = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0200,       // S1按键释放消息
    SP1K_MSG_KEY_RELEASE_S2 = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0201,       // S2按键释放消息
    SP1K_MSG_KEY_RELEASE_MENU = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0202,     // 菜单按键释放消息
    SP1K_MSG_KEY_RELEASE_UP = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0203,       // 上按键释放消息
    SP1K_MSG_KEY_RELEASE_DOWN = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0204,     // 下按键释放消息
    SP1K_MSG_KEY_RELEASE_LEFT = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0205,     // 左按键释放消息
    SP1K_MSG_KEY_RELEASE_RIGHT = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0206,    // 右按键释放消息
    SP1K_MSG_KEY_RELEASE_OK = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0207,       // 确认按键释放消息
    SP1K_MSG_KEY_RELEASE_TELE = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0208,     // 变焦放大按键释放消息
    SP1K_MSG_KEY_RELEASE_WIDE = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0209,     // 变焦缩小按键释放消息
    SP1K_MSG_KEY_RELEASE_DISP = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x020a,     // 显示按键释放消息
    SP1K_MSG_KEY_RELEASE_F1 = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x020b,       // F1按键释放消息
    SP1K_MSG_KEY_RELEASE_F2 = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x020c,       // F2按键释放消息
    SP1K_MSG_KEY_RELEASE_PB = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x020d,       // 回放按键释放消息
    SP1K_MSG_KEY_RELEASE_POWER = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x020e,    // 电源按键释放消息
    SP1K_MSG_KEY_RELEASE_MODE = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x020F,     // 模式按键释放消息
    SP1K_MSG_KEY_RELEASE_SNAP = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0210,     // 快照按键释放消息
    SP1K_MSG_KEY_RELEASE_SENSOR = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0211,   // 传感器按键释放消息
    SP1K_MSG_KEY_RELEASE_AF = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0212,       // 自动对焦按键释放消息
    SP1K_MSG_KEY_RELEASE_ZOOM_IN = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0213,  // 放大按键释放消息
    SP1K_MSG_KEY_RELEASE_ZOOM_OUT = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0214, // 缩小按键释放消息
    SP1K_MSG_KEY_RELEASE_BURST = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0215,    // 连拍按键释放消息
    SP1K_MSG_KEY_RELEASE_BACK = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0216,     // 返回按键释放消息
    SP1K_MSG_KEY_RELEASE_MAX = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0217,      // 按键释放消息最大值

    SP1K_MSG_KEY_REPEATE_UP = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0300,       // 上按键长按消息
    SP1K_MSG_KEY_REPEATE_DOWN = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0301,     // 下按键长按消息
    SP1K_MSG_KEY_REPEATE_LEFT = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0302,     // 左按键长按消息
    SP1K_MSG_KEY_REPEATE_RIGHT = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0303,    // 右按键长按消息
    SP1K_MSG_KEY_REPEATE_TELE = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0304,     // 变焦放大按键长按消息
    SP1K_MSG_KEY_REPEATE_WIDE = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0305,     // 变焦缩小按键长按消息
    SP1K_MSG_KEY_REPEATE_PB = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0306,       // 回放按键长按消息
    SP1K_MSG_KEY_REPEATE_POWER = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0307,    // 电源按键长按消息
    SP1K_MSG_KEY_REPEATE_MENU = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0308,     // 菜单按键长按消息
    SP1K_MSG_KEY_REPEATE_SNAP = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0309,     // 快照按键长按消息
    SP1K_MSG_KEY_REPEATE_SENSOR = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x030a,   // 传感器按键长按消息
    SP1K_MSG_KEY_REPEATE_AF = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x030b,       // 自动对焦按键长按消息
    SP1K_MSG_KEY_REPEATE_ZOOM_IN = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x030c,  // 放大按键长按消息
    SP1K_MSG_KEY_REPEATE_ZOOM_OUT = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x030d, // 缩小按键长按消息
    SP1K_MSG_KEY_REPEATE_BURST = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x030e,    // 连拍按键长按消息
    SP1K_MSG_KEY_REPEATE_BACK = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x030f,     // 返回按键长按消息
    SP1K_MSG_KEY_REPEATE_MAX = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0310,      // 按键长按消息最大值

    SP1K_MSG_KEY_MAX = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0400, // 按键消息最大值

    SP1K_MSG_UNKNOWN_BTN = ((UINT16)MSG_CTRL_TYPE_BTN << MSG_CTRL_IDX_GROUP_SHIFT) | 0x0fff, // 未知按键消息
} btnMsgList_t; 
```





> 按键AD值相关

- ADC A(SARIN0)

| 类别 |    按键对应AD值宏     | 读到的AD值 | 对应AD值(1023 - 读到的AD值) | 对称范围 |    区间     | 按键用途 |
| :--: | :-------------------: | :--------: | :-------------------------: | :------: | :---------: | :------: |
|  S1  | **SP1K_ADC_BTN_A_S1** |     0      |            1023             |   ±100   | [923, 1123] |  power   |

- ADC B(SARIN2)

| 类别 |    按键对应AD值宏     | 读到的AD值 | 对应AD值(1023 - 读到的AD值) | 对称范围 |    区间     | 按键用途 |
| :--: | :-------------------: | :--------: | :-------------------------: | :------: | :---------: | :------: |
|  S1  | **SP1K_ADC_BTN_B_S1** |    464     |             559             |   ±50    | [509, 609]  |  RIGHT1  |
|  S2  | **SP1K_ADC_BTN_B_S2** |    163     |             860             |   ±45    | [815, 905]  |   UP1    |
|  S3  | **SP1K_ADC_BTN_B_S3** |    308     |             715             |   ±50    | [665, 765]  |  BACK1   |
|  S4  | **SP1K_ADC_BTN_B_S4** |    930     |             93              |   ±50    |  [43, 143]  |  MODE1   |
|  S5  | **SP1K_ADC_BTN_B_S5** |    614     |             409             |   ±50    | [359, 459]  |  DOWN1   |
|  S6  | **SP1K_ADC_BTN_B_S6** |     0      |            1023             |   ±45    | [978, 1068] |   OK1    |
|  S7  | **SP1K_ADC_BTN_B_S7** |    748     |             275             |   ±50    | [225, 325]  |   DEL1   |



### 看门狗

> 硬件

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-10_20-40-36.webp)

| 网络标号 | 对应引脚 |      设置      |
| :------: | :------: | :------------: |
|  Watch   |  GPIO10  | GPIO模式，输出 |



> 步骤

1. 在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\host\app_dev\app_dev_disp.c`  里进行函数配置：

```cpp
#if SUPPORT_MCU_WTD // 【支持MCU做看门狗】
/**
* @param    falg: WTD_DOG_SET WTD_DOG_RESET
* @retval   None
* @brief    设置WTD看门狗心跳
**/
void appSetWTDHeartbeat(UINT8 falg) 
{
	// gpio 10
	gpioByteFuncSet(GPIO_BYTE_GEN1, GPIO_PIN_3, GPIO_PIN_3);
	gpioByteDirSet(GPIO_BYTE_GEN1, GPIO_PIN_3, GPIO_PIN_3);
	gpioByteOutSet(GPIO_BYTE_GEN1, GPIO_PIN_3, falg ? GPIO_PIN_3_SET : GPIO_PIN_RESET);
}
#endif
```



### SD卡

> 硬件

默认上拉，有SD卡插入则变成低电平

![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-10_20-45-05.webp)



| 网络标号 | 对应引脚 |      设置      |
| :------: | :------: | :------------: |
|  DGPIO0  |  DGPIO0  | GPIO模式，输入 |



> 步骤

1. 在 `E:\code\SPCA1627\240226_新板_按键_屏显_偏红_L_开关机_曝光\CDAF\drivers\package\package_1627.c` 里进行修改引脚即可，具体位看 `@gpioByte_e`	

```cpp
code pkgDedicateGpio_t pkgDedicateGpioTbl[] =
{
    // 略...
    {PKG_DEDICATE_PIN_SD_CD,      	GPIO_BYTE_DISP0,  	GPIO_PIN_1, 			ACTIVE_HIGH},
    {PKG_DEDICATE_PIN_SD_WP,      	GPIO_BYTE_DISP0,  	GPIO_PIN_1, 			ACTIVE_HIGH}
    // 略...
}
```



## 常用应用层API

> UINT8 **appImgDecode**(UINT32 resId)
>
> 通过传入图片ID进行显示图片在屏幕上

> UINT8 **appOpenImgDec**(UINT8 mode)
>
> 通过模式进行选择进行显示图片在屏幕上，可以是Excel里的某些参数(里面实现最终也是调用 `appImgDecode()`函数进行显示)

> UINT8 **osMsgPost** (UINT16 msg)
>
> 将消息（事件）安全地发布到操作系统的消息队列中

> **sp1kOsdClearCharExt**(SINT16 x,SINT16 y,UINT16 w,UINT16 h)
>
> 清除OSD上指定区域的字符显示

> void **sp1kOsdClear** (UINT8 attr)
>
> 清除OSD显示区域
>
> `attr`：OSD显示属性

> UINT8 **sp1kNandRsvWrite**(UINT32 idx, UINT32 addr)
>
> SPI Flash往addr地址里写入idx固件

> void **sp1kSuperPreviewSet**(UINT8 mode, UINT8 en)
>
> `函数功能`：启用/禁用超级预览模式（不支持录音）
>
> `mode`：0: 静态预览模式  1: 视频预览模式
>
> `en`：0：禁止超级预览 1：启用超级预览

> void **sp1kVideoCapStart**(void)
>
> `函数功能`：启动速拍功能

> void **uiOsdDialogDisp**(UINT8 stridx, UINT16 wait)
>
> `函数功能`：显示消息对话框
>
> `stridx`：要显示的字符串索引
>
> `wait`：显示完成后等待时间

> void **app_quick_delete_dialog**(UINT8 cur_idx)
>
> `函数功能`：快速删除对话框
>
> `cur_idx`: 当前选中的索引

> UINT8 **sp1kSnapParamSet**(UINT8 attrId, UINT16 value)
>
> `函数功能`：设置快照参数
>
> `attrId`：参数的 idx
>
> `value`：参数值
>
> `返回值`：SUCCESS / FAIL

> void **sp1kPvPhotofrmEnable**(UINT8 enable)
>
> 启用或禁用PV模式下的相框功能

> UINT8 **appPvPhotoFrameSet**(UINT8 idx)
>
> 设置相框

> UINT8 **sp1kSpeedyCapStsGet**()
>
> 获取快速拍照状态

> **sp1kFdEnable**()
>
> 启用或禁用脸部检测



## 常用HAL API

> void **gpioByteFuncSet**(UINT8 byteId, UINT8 msk, UINT8 func)
>
> `函数功能`：初始化GPIO功能
>
> `byteId`：对应端口组，查看@HAL_GpioByte_e
>
> ```cpp
> typedef enum
> {
>     HAL_GPIO_BYTE_NULL,
>     HAL_GPIO_BYTE_GEN0,   /* gpio[7:0]		*/
>     HAL_GPIO_BYTE_GEN1,   /* gpio[15:8] 	*/
>     HAL_GPIO_BYTE_GEN2,   /* gpio[23:16]	*/
>     HAL_GPIO_BYTE_GEN3,   /* gpio[26:24]	*/
>     HAL_GPIO_BYTE_FM0,	/* fmgpio[7:0]*/
>     HAL_GPIO_BYTE_FM1,	/* fmgpio[15:8]*/
>     HAL_GPIO_BYTE_FM2,	/* fmgpio[19:16]*/
>     HAL_GPIO_BYTE_TG0,	  /* tggpio[5:0]	*/
>     HAL_GPIO_BYTE_DISP0,  /* tvegpio[7:0]	*/
>     HAL_GPIO_BYTE_DISP1,  /* tvegpio[15:8]	*/
>     HAL_GPIO_BYTE_DISP2,  /* tvegpio[23:16] */
>     HAL_GPIO_BYTE_DISP3,  /* tvegpio[27:24] */
>     HAL_GPIO_BYTE_MA1,	  /* ma[14:14]		*/
>     HAL_GPIO_BYTE_RGB0,   /* rgb[7:0]		*/
>     HAL_GPIO_BYTE_RGB1,   /* rgb[9:8]		*/
>     HAL_GPIO_BYTE_MAX,
> } HAL_GpioByte_e;
> ```
>
> `msk`：位图掩码，用于指定要设置的位，即端口组的具体到哪个引脚，可参考用户自定义枚举类型：
>
> ```cpp
> // GPIO引脚编号枚举类型
> typedef enum
> {
>     GPIO_PIN_1 = 0x01,  // 引脚1
>     GPIO_PIN_2 = 0x02,  // 引脚2
>     GPIO_PIN_3 = 0x04,  // 引脚3
>     GPIO_PIN_4 = 0x08,  // 引脚4
>     GPIO_PIN_5 = 0x10,  // 引脚5
>     GPIO_PIN_6 = 0x20,  // 引脚6
>     GPIO_PIN_7 = 0x40,  // 引脚7
>     GPIO_PIN_8 = 0x80   // 引脚8
> } GPIO_Pin_TypeDef_et;
> ```
>
> `func`：功能选择(图功能，0：功能，1：gpio)，需要操作到位

> void **gpioByteDirSet**(UINT8 byteId, UINT8 msk, UINT8 dir)
>
> `函数功能`：设置 gpio 方向
>
> `byteId`：对应端口组，查看@HAL_GpioByte_e
>
> `msk`：位图掩码，用于指定要设置的位，即端口组的具体到哪个引脚，参考@GPIO_Pin_TypeDef_et
>
> `dir`：位图方向，0：输入，1：输出，需要操作到位

> void **gpioByteOutSet**(UINT8 byteId, UINT8 msk, UINT8 val)
>
> `函数功能`：设置 gpio 输出电平
>
> `byteId`：对应端口组，查看@HAL_GpioByte_e
>
> `msk`：位图掩码，用于指定要设置的位，即端口组的具体到哪个引脚，参考@GPIO_Pin_TypeDef_et
>
> `val`：电平值 0/1，但是设置1不能直接传入1，需要传入某位，所以需要跟msk一致，低电平则无需这样直接传入0即可，可参考用户自定义枚举类型：
>
> ```cpp
> // GPIO电平状态枚举类型
> typedef enum
> {
>     GPIO_PIN_RESET = 0,  // 引脚低电平
>     GPIO_PIN_1_SET   = GPIO_PIN_1,   // 引脚1(0x01)高电平
>     GPIO_PIN_2_SET   = GPIO_PIN_2,   // 引脚2(0x02)高电平
>     GPIO_PIN_3_SET   = GPIO_PIN_3,   // 引脚3(0x04)高电平
>     GPIO_PIN_4_SET   = GPIO_PIN_4,   // 引脚4(0x08)高电平
>     GPIO_PIN_5_SET   = GPIO_PIN_5,   // 引脚5(0x10)高电平
>     GPIO_PIN_6_SET   = GPIO_PIN_6,   // 引脚6(0x20)高电平
>     GPIO_PIN_7_SET   = GPIO_PIN_7,   // 引脚7(0x40)高电平
>     GPIO_PIN_8_SET   = GPIO_PIN_8,   // 引脚8(0x80)高电平
> } GPIO_PinState_et;
> ```

> UINT8 **sp1kHalWait**(UINT32 WaitTime)
>
> `函数功能`：系统延时，时间由全局Timer 1 的上计数模式计算
>
> `WaitTime`：以毫秒为单位指定的等待时间
>
> `返回值`：return = SUCCESS / FAIL，如果延时时间设置超出最大值则返回错误

> void **sp1kPullEnSet**(UINT8 byteId, UINT8 msk, UINT8 en)
>
> `函数功能`：使能内部上下拉
>
> `byteId`：0-12组
>
> ```cpp
> 【byteId = 0】
> bit [0] = fmgpio[0]
> bit [1] = fmgpio[1]
> bit [2] = fmgpio[2]
> bit [3] = fmgpio[3]
> bit [4] = fmgpio[4]
> bit [5] = fmgpio[5]
> bit [6] = fmgpio[6]
> bit [7] = fmgpio[7]
> 【byteId = 1】
> bit [0] = fmgpio[8]
> bit [1] = fmgpio[9]
> bit [2] = fmgpio[10]
> bit [3] = fmgpio[11]
> bit [4] = fmgpio[12]
> bit [5] = fmgpio[13]
> bit [6] = fmgpio[14]
> bit [7] = fmgpio[15]
> 【byteId = 2】    
> bit [0] = fmgpio[16]
> bit [1] = fmgpio[17]
> bit [2] = fmgpio[18]
> bit [3] = fmgpio[19]
> bit [4] = ma[0]
> bit [5] = ma[1]
> bit [6] = ma[2]
> bit [7] = ma[3]
> 【byteId = 3】    
> bit [0] = ma[4]
> bit [1] = ma[5]
> bit [2] = ma[6]
> bit [3] = ma[7]
> bit [4] = ma[8]
> bit [5] = ma[9]
> bit [6] = ma[10]
> bit [7] = ma[11]
> 【byteId = 4】
> bit [0] = ma[14]
> bit [1] = gpio[0]
> bit [2] = gpio[1]
> bit [3] = gpio[2]
> bit [4] = gpio[3]
> bit [5] = gpio[4]
> bit [6] = gpio[5]
> bit [7] = gpio[6]
> 【byteId = 5】
> bit [0] = gpio[7]
> bit [1] = gpio[8]
> bit [2] = gpio[9]
> bit [3] = gpio[10]
> bit [4] = gpio[11]
> bit [5] = gpio[12]
> bit [6] = gpio[13]
> bit [7] = gpio[14]
> 【byteId = 6】
> bit [0] = gpio[15]
> bit [1] = gpio[16]
> bit [2] = gpio[17]
> bit [3] = gpio[18]
> bit [4] = gpio[19]
> bit [5] = gpio[20]
> bit [6] = gpio[21]
> bit [7] = gpio[22]
> 【byteId = 7】
> bit [0] = gpio[23]
> bit [1] = gpio[24]
> bit [2] = sar3
> bit [3] = sar4
> bit [4] = digtv[0]
> bit [5] = digtv[1]
> bit [6] = digtv[2]
> bit [7] = digtv[3]
> 【byteId = 8】
> bit [0] = digtv[4]
> bit [1] = digtv[5]
> bit [2] = digtv[6]
> bit [3] = digtv[7]
> bit [4] = digtv[8]
> bit [5] = digtv[9]
> bit [6] = digtv[10]
> bit [7] = digtv[11]
> 【byteId = 9】
> bit [0] = digtv[12]
> bit [1] = digtv[13]
> bit [2] = digtv[14]
> bit [3] = digtv[15]
> bit [4] = digtv[16]
> bit [5] = digtv[17]
> bit [6] = digtv[10]
> bit [7] = digtv[19]
> 【byteId = 10】
> bit [0] = digtv[20]
> bit [1] = digtv[21]
> bit [2] = digtv[22]
> bit [3] = digtv[23]
> bit [4] = digtv[24]
> bit [5] = digtv[25]
> bit [6] = digtv[26]
> bit [7] = digtv[27]
> 【byteId = 11】
> bit [0] = rgb[0]
> bit [1] = rgb[1]
> bit [2] = rgb[2]
> bit [3] = rgb[3]
> bit [4] = rgb[4]
> bit [5] = rgb[5]
> bit [6] = rgb[6]
> bit [7] = rgb[7]
> 【byteId = 12】
> bit [0] = rgb[8]
> bit [1] = rgb[9]
> bit [2] = tggpio[0]
> bit [3] = tggpio[1]
> bit [4] = tggpio[2]
> bit [5] = tggpio[3]
> bit [6] = tggpio[4]
> bit [7] = tggpio[5]
> ```
>
> `msk`：位图掩码，用于指定要设置的位，即端口组的具体到哪个引脚，参考上面这个形参即可
>
> `en`：使能位，功能选择(图功能，0：功能，1：gpio)，要设置到对应位

> void **sp1kPullSelSet**(UINT8 byteId, UINT8 msk, UINT8 sel)
>
> `函数功能`：选择内部上拉/下拉
>
> `byteId`：0-9
>
> ```cpp
> 【byteId = 0】
> bit [0] = fmgpio[0]
> bit [1] = fmgpio[1]
> bit [2] = fmgpio[2]
> bit [3] = fmgpio[3]
> bit [4] = fmgpio[4]
> bit [5] = fmgpio[5]
> bit [6] = fmgpio[6]
> bit [7] = fmgpio[7]
> 
> 【byteId = 1】
> bit [0] = fmgpio[8]
> bit [1] = fmgpio[9]
> bit [2] = fmgpio[10]
> bit [3] = fmgpio[11]
> bit [4] = fmgpio[12]
> bit [5] = fmgpio[13]
> bit [6] = fmgpio[14]
> bit [7] = fmgpio[15]
> 
> 【byteId = 2】
> bit [0] = fmgpio[16]
> bit [1] = fmgpio[17]
> bit [2] = fmgpio[18]
> bit [3] = fmgpio[19]
> bit [4] = ma[14]
> bit [5] = gpio[0]
> bit [6] = gpio[1]
> bit [7] = gpio[2]
> 
> 【byteId = 3】
> bit [0] = gpio[3]
> bit [1] = gpio[4]
> bit [2] = gpio[5]
> bit [3] = gpio[6]
> bit [4] = gpio[7]
> bit [5] = gpio[8]
> bit [6] = gpio[9]
> bit [7] = gpio[10]
> 
> 【byteId = 4】
> bit [0] = gpio[11]
> bit [1] = gpio[12]
> bit [2] = gpio[13]
> bit [3] = gpio[14]
> bit [4] = gpio[15]
> bit [5] = gpio[16]
> bit [6] = gpio[17]
> bit [7] = gpio[18]
> 
> 【byteId = 5】
> bit [0] = gpio[19]
> bit [1] = gpio[20]
> bit [2] = gpio[21]
> bit [3] = gpio[22]
> bit [4] = gpio[23]
> bit [5] = gpio[24]
> bit [6] = sar3
> bit [7] = sar4
> 
> 【byteId = 6】
> bit [0] = digtv[0]
> bit [1] = digtv[1]
> bit [2] = digtv[2]
> bit [3] = digtv[3]
> bit [4] = digtv[4]
> bit [5] = digtv[5]
> bit [6] = digtv[6]
> bit [7] = digtv[7]
> 
> 【byteId = 7】
> bit [0] = digtv[8]
> bit [1] = digtv[9]
> bit [2] = digtv[10]
> bit [3] = digtv[11]
> bit [4] = digtv[12]
> bit [5] = digtv[13]
> bit [6] = digtv[14]
> bit [7] = digtv[15]
> 
> 【byteId = 8】
> bit [0] = digtv[16]
> bit [1] = digtv[17]
> bit [2] = digtv[10]
> bit [3] = digtv[19]
> bit [4] = digtv[20]
> bit [5] = digtv[21]
> bit [6] = digtv[22]
> bit [7] = digtv[23]
> 
> 【byteId = 9】
> bit [0] = digtv[24]
> bit [1] = digtv[25]
> bit [2] = digtv[26]
> bit [3] = digtv[27]
> bit [4] = tggpio[0]
> bit [5] = tggpio[1]
> bit [6] = tggpio[2]
> bit [7] = tggpio[3]
> ```
>
> `msk`：位图掩码，用于指定要设置的位，即端口组的具体到哪个引脚，参考上面这个形参即可
>
> `sel`：选择上拉/下拉 0: 下拉 1:上拉，要设置到对应位

>  `void pkgDedicateGpioCfg(UINT8 pinId, UINT8 *pbyteId, UINT8 *pbitMsk, UINT8*ppolarity, UINT8 dir)`
>
> `封闭函数`
>
> `函数功能`：用于配置一个特定的GPIO管脚
>
> `dir`：方向，0：输入 1：输出

> UINT8 **gpioByteInGet**(UINT8 byteId, UINT8 msk, UINT8 polarity)
>
> `函数功能`：获取 gpio 输入
>
> `byteId`：对应端口组，查看@HAL_GpioByte_e
>
> `msk`：位图掩码，用于指定要设置的位，即端口组的具体到哪个引脚，可参考用户自定义枚举类型@GPIO_Pin_TypeDef_et
>
> `polarity`：硬件输入 0：低电平有效 1：高电平有效

> void **HAL_GpioByteDirSet_Intr**(UINT8 byteId, UINT8 msk, UINT8 dir)
>
> `函数功能`：设置中断服务使用的 gpio 方向
>
> `byteId`：对应端口组，查看@HAL_GpioByte_e
>
> `msk`：位图掩码，用于指定要设置的位，即端口组的具体到哪个引脚，可参考用户自定义枚举类型@GPIO_Pin_TypeDef_et
>
> `dir`：位图方向，0：输入，1：输出，要设置到对应位

> UINT16 **sp1kADCValueSnapIntr**(void)
>
> `函数功能`：捕捉刚刚在中断中使用的 ADC 值 
>
> `返回值`：ADC 值







## 注意事项

> 下载的话，可以使用上位机或者SD卡
>
> 1. 上位机 `iCatch_E_ISP`
>
> 需要先下载驱动 `SPCA1628_V1210_WHQL.exe`，直接安装即可。 然后这下面是直接两个Bin文件即可，然后点击【OK】等待下载完成
>
> ![](https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/PixPin_2024-03-05_20-38-01.webp)
>
> 2. SD卡
>
> 把3个文件放到SD卡里，分别是：`DRAMPARA.txt`，`ISP.BIN`，`1628.bin`(其中前两个是固定的可以去 `download`文件夹里那些 `.zip` 里面直接复制即可，后面那个是每次编译生成的)
>
> 然后把卡插入到板子里，上电会有提升正在升级，看蓝色LED，灭了就是升级好就可以把卡拿出来，不然待会又检测到卡里有升级文件就又重新升级了，这个SD卡是存储图片的，所以升级完需要把升级文件删除再插回去即可

> 编译出现错误的话可以试试：
>
> 1. 执行工程下的 `clean.cmd` 再进行全局编译

> 工程的文件不要改名字

> 串口波特率是: 57600

> 修改了 `kernel` 文件夹的内容需要到对应修改的地方找到 Keil程序进行编译一下！！！
>
> 其他文件夹类似，反正跑一遍就行以防万一

> 注意有一些文件是通过脚本进行生成覆盖的，我们不需要改，一般是 `drv_` 前缀的文件，脚本主要是涉及到 `copy /y` 复制文件

> 复位一般是 `拉高->拉低-> 拉高` 操作，中间需要加延时

> 打包的话，编译生成的bin文件+其他两个固定文件，一起压缩即可，压缩包名字需要改一下时间什么的，bin改名为1628.bin

> 声音不对的话改声音文件，加长点空白时间，使用音频修改软件，改完需要在Excel需修改版本号



## 快捷键

-  文件夹

> `F2`：重命名

> 改名字过程中按Tab换下一个

- PS

> 修改图像大小时，改一个后连续按两次Tab切换下一个

> 放大/缩小当前对象，按  `Ctrl + +/-` 进行缩放，按 `ctrl + 0` 恢复默认